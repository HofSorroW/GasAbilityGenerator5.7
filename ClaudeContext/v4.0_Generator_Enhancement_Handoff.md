# GasAbilityGenerator v4.0 Enhancement Handoff

**Created:** 2026-01-14
**Purpose:** Implementation specifications for enhancing BB_, BT_, M_, MF_, FC_ generators
**Target:** Increase automation levels to 95-100%

---

## Table of Contents

1. [Overview](#overview)
2. [Phase 1: Critical Fixes](#phase-1-critical-fixes)
   - [1.1 Material Function Connection Wiring (MF_)](#11-material-function-connection-wiring-mf_)
   - [1.2 Blackboard Enhancements (BB_)](#12-blackboard-enhancements-bb_)
   - [1.3 Float Curve Enhancements (FC_)](#13-float-curve-enhancements-fc_)
3. [Phase 2: Behavior Tree Enhancements (BT_)](#phase-2-behavior-tree-enhancements-bt_)
4. [Phase 3: Material Enhancements (M_)](#phase-3-material-enhancements-m_)
5. [Testing Checklist](#testing-checklist)

---

## Overview

### Current vs Target Automation Levels

| Generator | Current | Target | Primary Gaps |
|-----------|---------|--------|--------------|
| BB_ Blackboards | 98% | 100% | Key base class, parent inheritance |
| BT_ Behavior Trees | 80% | 95% | Child connections, property reflection |
| M_ Materials | 85% | 95% | TextureSample, material properties |
| MF_ Material Functions | 85% | 98% | **Connection wiring (critical bug)** |
| FC_ Float Curves | 98% | 100% | Interpolation modes, extrapolation |

### Files to Modify

| File | Purpose |
|------|---------|
| `Source/GasAbilityGenerator/Public/GasAbilityGeneratorTypes.h` | Struct definitions |
| `Source/GasAbilityGenerator/Private/GasAbilityGeneratorParser.cpp` | YAML parsing |
| `Source/GasAbilityGenerator/Private/GasAbilityGeneratorGenerators.cpp` | Asset generation |

---

## Phase 1: Critical Fixes

### 1.1 Material Function Connection Wiring (MF_)

**Problem:** Connections are parsed from manifest but never applied to the material function. The generator logs "connections may need manual setup" and skips wiring.

**Location:** `GasAbilityGeneratorGenerators.cpp` line ~3960

**Current Code (broken):**
```cpp
// Create connections (simplified - function outputs have different connection API)
// For now, log that connections need manual setup for complex cases
if (Definition.Connections.Num() > 0)
{
    LogGeneration(Results, EGenerationLogLevel::Info,
        FString::Printf(TEXT("Material function %s has %d connections defined - connections may need manual setup for complex cases"),
            *Definition.Name, Definition.Connections.Num()));
}
```

**Fixed Code - Replace the above with:**

```cpp
// ============================================================================
// MATERIAL FUNCTION CONNECTION WIRING - v4.0 Fix
// ============================================================================

// Build expression map for connection lookup
TMap<FString, UMaterialExpression*> ExpressionMap;
for (UMaterialExpression* Expr : MaterialFunction->GetExpressions())
{
    // Map by expression description (set during creation as the Id)
    if (!Expr->Desc.IsEmpty())
    {
        ExpressionMap.Add(Expr->Desc, Expr);
    }
}

// Also add function inputs/outputs to map
for (UMaterialExpression* Expr : MaterialFunction->GetExpressions())
{
    if (UMaterialExpressionFunctionInput* InputExpr = Cast<UMaterialExpressionFunctionInput>(Expr))
    {
        ExpressionMap.Add(InputExpr->InputName.ToString(), Expr);
    }
    else if (UMaterialExpressionFunctionOutput* OutputExpr = Cast<UMaterialExpressionFunctionOutput>(Expr))
    {
        ExpressionMap.Add(OutputExpr->OutputName.ToString(), Expr);
    }
}

// Wire connections
int32 ConnectionsWired = 0;
for (const FManifestMaterialConnectionDefinition& Conn : Definition.Connections)
{
    UMaterialExpression* FromExpr = ExpressionMap.FindRef(Conn.FromNode);
    UMaterialExpression* ToExpr = ExpressionMap.FindRef(Conn.ToNode);

    if (!FromExpr)
    {
        LogGeneration(Results, EGenerationLogLevel::Warning,
            FString::Printf(TEXT("MF %s: Connection source '%s' not found"), *Definition.Name, *Conn.FromNode));
        continue;
    }
    if (!ToExpr)
    {
        LogGeneration(Results, EGenerationLogLevel::Warning,
            FString::Printf(TEXT("MF %s: Connection target '%s' not found"), *Definition.Name, *Conn.ToNode));
        continue;
    }

    // Find output index on source expression
    int32 OutputIndex = 0;
    if (!Conn.FromPin.IsEmpty())
    {
        // Search for named output
        TArray<FExpressionOutput>& Outputs = FromExpr->GetOutputs();
        for (int32 i = 0; i < Outputs.Num(); i++)
        {
            if (Outputs[i].OutputName.ToString().Equals(Conn.FromPin, ESearchCase::IgnoreCase))
            {
                OutputIndex = i;
                break;
            }
        }
        // Also check for common aliases
        if (Conn.FromPin.Equals(TEXT("RGB"), ESearchCase::IgnoreCase)) OutputIndex = 0;
        else if (Conn.FromPin.Equals(TEXT("R"), ESearchCase::IgnoreCase)) OutputIndex = 1;
        else if (Conn.FromPin.Equals(TEXT("G"), ESearchCase::IgnoreCase)) OutputIndex = 2;
        else if (Conn.FromPin.Equals(TEXT("B"), ESearchCase::IgnoreCase)) OutputIndex = 3;
        else if (Conn.FromPin.Equals(TEXT("A"), ESearchCase::IgnoreCase)) OutputIndex = 4;
    }

    // Find and connect input on target expression
    bool bConnected = false;

    // Handle FunctionOutput specially - it has a single input
    if (UMaterialExpressionFunctionOutput* OutputExpr = Cast<UMaterialExpressionFunctionOutput>(ToExpr))
    {
        OutputExpr->A.Expression = FromExpr;
        OutputExpr->A.OutputIndex = OutputIndex;
        bConnected = true;
    }
    else
    {
        // Generic input connection by name
        FExpressionInput* TargetInput = nullptr;

        // Try common input names
        if (Conn.ToPin.IsEmpty() || Conn.ToPin.Equals(TEXT("A"), ESearchCase::IgnoreCase))
        {
            // First input
            if (UMaterialExpressionMultiply* Mul = Cast<UMaterialExpressionMultiply>(ToExpr))
                TargetInput = &Mul->A;
            else if (UMaterialExpressionAdd* Add = Cast<UMaterialExpressionAdd>(ToExpr))
                TargetInput = &Add->A;
            else if (UMaterialExpressionSubtract* Sub = Cast<UMaterialExpressionSubtract>(ToExpr))
                TargetInput = &Sub->A;
            else if (UMaterialExpressionDivide* Div = Cast<UMaterialExpressionDivide>(ToExpr))
                TargetInput = &Div->A;
            else if (UMaterialExpressionPower* Pow = Cast<UMaterialExpressionPower>(ToExpr))
                TargetInput = &Pow->Base;
            else if (UMaterialExpressionLerp* Lerp = Cast<UMaterialExpressionLerp>(ToExpr))
                TargetInput = &Lerp->A;
            else if (UMaterialExpressionClamp* Clamp = Cast<UMaterialExpressionClamp>(ToExpr))
                TargetInput = &Clamp->Input;
            else if (UMaterialExpressionOneMinus* OneMinus = Cast<UMaterialExpressionOneMinus>(ToExpr))
                TargetInput = &OneMinus->Input;
            else if (UMaterialExpressionSine* Sine = Cast<UMaterialExpressionSine>(ToExpr))
                TargetInput = &Sine->Input;
            else if (UMaterialExpressionFresnel* Fresnel = Cast<UMaterialExpressionFresnel>(ToExpr))
                TargetInput = &Fresnel->BaseReflectFractionIn;
        }
        else if (Conn.ToPin.Equals(TEXT("B"), ESearchCase::IgnoreCase))
        {
            // Second input
            if (UMaterialExpressionMultiply* Mul = Cast<UMaterialExpressionMultiply>(ToExpr))
                TargetInput = &Mul->B;
            else if (UMaterialExpressionAdd* Add = Cast<UMaterialExpressionAdd>(ToExpr))
                TargetInput = &Add->B;
            else if (UMaterialExpressionSubtract* Sub = Cast<UMaterialExpressionSubtract>(ToExpr))
                TargetInput = &Sub->B;
            else if (UMaterialExpressionDivide* Div = Cast<UMaterialExpressionDivide>(ToExpr))
                TargetInput = &Div->B;
            else if (UMaterialExpressionPower* Pow = Cast<UMaterialExpressionPower>(ToExpr))
                TargetInput = &Pow->Exponent;
            else if (UMaterialExpressionLerp* Lerp = Cast<UMaterialExpressionLerp>(ToExpr))
                TargetInput = &Lerp->B;
        }
        else if (Conn.ToPin.Equals(TEXT("Alpha"), ESearchCase::IgnoreCase))
        {
            if (UMaterialExpressionLerp* Lerp = Cast<UMaterialExpressionLerp>(ToExpr))
                TargetInput = &Lerp->Alpha;
        }
        else if (Conn.ToPin.Equals(TEXT("Min"), ESearchCase::IgnoreCase))
        {
            if (UMaterialExpressionClamp* Clamp = Cast<UMaterialExpressionClamp>(ToExpr))
                TargetInput = &Clamp->Min;
        }
        else if (Conn.ToPin.Equals(TEXT("Max"), ESearchCase::IgnoreCase))
        {
            if (UMaterialExpressionClamp* Clamp = Cast<UMaterialExpressionClamp>(ToExpr))
                TargetInput = &Clamp->Max;
        }
        else if (Conn.ToPin.Equals(TEXT("Coordinate"), ESearchCase::IgnoreCase))
        {
            if (UMaterialExpressionPanner* Panner = Cast<UMaterialExpressionPanner>(ToExpr))
                TargetInput = &Panner->Coordinate;
        }
        else if (Conn.ToPin.Equals(TEXT("Time"), ESearchCase::IgnoreCase))
        {
            if (UMaterialExpressionPanner* Panner = Cast<UMaterialExpressionPanner>(ToExpr))
                TargetInput = &Panner->Time;
        }

        if (TargetInput)
        {
            TargetInput->Expression = FromExpr;
            TargetInput->OutputIndex = OutputIndex;
            bConnected = true;
        }
    }

    if (bConnected)
    {
        ConnectionsWired++;
    }
    else
    {
        LogGeneration(Results, EGenerationLogLevel::Warning,
            FString::Printf(TEXT("MF %s: Could not wire connection %s.%s -> %s.%s"),
                *Definition.Name, *Conn.FromNode, *Conn.FromPin, *Conn.ToNode, *Conn.ToPin));
    }
}

if (ConnectionsWired > 0)
{
    LogGeneration(Results, EGenerationLogLevel::Info,
        FString::Printf(TEXT("MF %s: Wired %d/%d connections"),
            *Definition.Name, ConnectionsWired, Definition.Connections.Num()));
}

// Mark material function as needing recompilation
MaterialFunction->PreEditChange(nullptr);
MaterialFunction->PostEditChange();
```

**Additional struct fields for MF_ metadata** (add to `GasAbilityGeneratorTypes.h`):

```cpp
// In FManifestMaterialFunctionInputDefinition:
USTRUCT()
struct FManifestMaterialFunctionInputDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    FString Name;

    UPROPERTY()
    FString Type;  // float, float2, float3, float4

    UPROPERTY()
    float DefaultValue = 0.0f;

    UPROPERTY()
    int32 SortPriority = 0;

    // NEW v4.0:
    UPROPERTY()
    FString Description;

    UPROPERTY()
    bool bUsePreviewValueAsDefault = false;
};

// In FManifestMaterialFunctionDefinition - add after existing fields:
    // NEW v4.0:
    UPROPERTY()
    FString UserExposedCaption;  // Display name in material editor

    UPROPERTY()
    TArray<FString> LibraryCategories;  // ["Effects", "Father", "VFX"]

    UPROPERTY()
    FString PreviewBlendMode;  // Translucent, Opaque, etc.

    UPROPERTY()
    FString PreviewMaterialDomain;  // Surface, PostProcess
```

**Parser additions for MF_** (add to `ParseMaterialFunctions` in `GasAbilityGeneratorParser.cpp`):

```cpp
// After parsing existing fields, add:
else if (Key == TEXT("user_exposed_caption"))
{
    CurrentFunction.UserExposedCaption = Value;
}
else if (Key == TEXT("library_categories"))
{
    // Parse as array: [Category1, Category2]
    FString ArrayStr = Value;
    ArrayStr.RemoveFromStart(TEXT("["));
    ArrayStr.RemoveFromEnd(TEXT("]"));
    TArray<FString> Categories;
    ArrayStr.ParseIntoArray(Categories, TEXT(","));
    for (FString& Cat : Categories)
    {
        Cat.TrimStartAndEndInline();
        CurrentFunction.LibraryCategories.Add(Cat);
    }
}
else if (Key == TEXT("preview_blend_mode"))
{
    CurrentFunction.PreviewBlendMode = Value;
}
else if (Key == TEXT("preview_material_domain"))
{
    CurrentFunction.PreviewMaterialDomain = Value;
}

// In input parsing section, add:
else if (InputKey == TEXT("description"))
{
    CurrentInput.Description = InputValue;
}
else if (InputKey == TEXT("use_preview_value_as_default"))
{
    CurrentInput.bUsePreviewValueAsDefault = InputValue.ToBool();
}
```

**Generator additions for MF_ metadata** (add after MaterialFunction creation):

```cpp
// Set metadata properties - v4.0
if (!Definition.UserExposedCaption.IsEmpty())
{
    MaterialFunction->UserExposedCaption = FText::FromString(Definition.UserExposedCaption);
}

if (Definition.LibraryCategories.Num() > 0)
{
    MaterialFunction->LibraryCategoriesText.Empty();
    for (const FString& Category : Definition.LibraryCategories)
    {
        MaterialFunction->LibraryCategoriesText.Add(FText::FromString(Category));
    }
}

if (!Definition.PreviewBlendMode.IsEmpty())
{
    if (Definition.PreviewBlendMode.Equals(TEXT("Opaque"), ESearchCase::IgnoreCase))
        MaterialFunction->PreviewBlendMode = BLEND_Opaque;
    else if (Definition.PreviewBlendMode.Equals(TEXT("Masked"), ESearchCase::IgnoreCase))
        MaterialFunction->PreviewBlendMode = BLEND_Masked;
    else if (Definition.PreviewBlendMode.Equals(TEXT("Translucent"), ESearchCase::IgnoreCase))
        MaterialFunction->PreviewBlendMode = BLEND_Translucent;
    else if (Definition.PreviewBlendMode.Equals(TEXT("Additive"), ESearchCase::IgnoreCase))
        MaterialFunction->PreviewBlendMode = BLEND_Additive;
    else if (Definition.PreviewBlendMode.Equals(TEXT("Modulate"), ESearchCase::IgnoreCase))
        MaterialFunction->PreviewBlendMode = BLEND_Modulate;
}
```

---

### 1.2 Blackboard Enhancements (BB_)

**Location:** `GasAbilityGeneratorTypes.h`

**Updated struct definitions:**

```cpp
USTRUCT()
struct FManifestBlackboardKeyDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    FString Name;

    UPROPERTY()
    FString Type;  // Bool, Int, Float, String, Name, Vector, Rotator, Object, Class, Enum

    UPROPERTY()
    bool bInstanceSynced = false;

    // NEW v4.0:
    UPROPERTY()
    FString BaseClass;  // For Object/Class keys: "ACharacter", "ANarrativeNPCCharacter"

    UPROPERTY()
    FString Description;  // Editor tooltip

    UPROPERTY()
    FString Category;  // Key grouping: "Combat", "Movement", "State"

    FString ComputeHash() const
    {
        return FString::Printf(TEXT("%s_%s_%d_%s_%s_%s"),
            *Name, *Type, bInstanceSynced ? 1 : 0, *BaseClass, *Description, *Category);
    }
};

USTRUCT()
struct FManifestBlackboardDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    FString Name;

    UPROPERTY()
    FString Folder;

    UPROPERTY()
    TArray<FManifestBlackboardKeyDefinition> Keys;

    // NEW v4.0:
    UPROPERTY()
    FString Parent;  // Parent blackboard for inheritance: "BB_Base"

    FString ComputeHash() const
    {
        FString KeysHash;
        for (const FManifestBlackboardKeyDefinition& Key : Keys)
        {
            KeysHash += Key.ComputeHash();
        }
        return FString::Printf(TEXT("%s_%s_%s_%s"), *Name, *Folder, *Parent, *KeysHash);
    }
};
```

**Parser additions** (in `ParseBlackboards` function):

```cpp
// Add after existing key parsing:
else if (KeyProp == TEXT("base_class"))
{
    CurrentKey.BaseClass = KeyValue;
}
else if (KeyProp == TEXT("description"))
{
    CurrentKey.Description = KeyValue;
}
else if (KeyProp == TEXT("category"))
{
    CurrentKey.Category = KeyValue;
}

// Add at blackboard level:
else if (Key == TEXT("parent"))
{
    CurrentBlackboard.Parent = Value;
}
```

**Generator updates** (in `FBlackboardGenerator::Generate`):

```cpp
// ============================================================================
// BLACKBOARD GENERATOR v4.0 ENHANCEMENTS
// ============================================================================

// After creating UBlackboardData, before adding keys:

// Handle parent blackboard inheritance
if (!Definition.Parent.IsEmpty())
{
    FString ParentPath = FString::Printf(TEXT("/Game/%s/AI/Blackboards/%s.%s"),
        *ProjectName, *Definition.Parent, *Definition.Parent);

    UBlackboardData* ParentBB = LoadObject<UBlackboardData>(nullptr, *ParentPath);
    if (!ParentBB)
    {
        // Try alternate paths
        ParentPath = FString::Printf(TEXT("/Game/%s/%s.%s"),
            *ProjectName, *Definition.Parent, *Definition.Parent);
        ParentBB = LoadObject<UBlackboardData>(nullptr, *ParentPath);
    }

    if (ParentBB)
    {
        BlackboardData->Parent = ParentBB;
        LogGeneration(Results, EGenerationLogLevel::Info,
            FString::Printf(TEXT("BB %s: Set parent to %s"), *Definition.Name, *Definition.Parent));
    }
    else
    {
        LogGeneration(Results, EGenerationLogLevel::Warning,
            FString::Printf(TEXT("BB %s: Parent blackboard '%s' not found"), *Definition.Name, *Definition.Parent));
    }
}

// In the key creation loop, replace the Object/Class key handling:
if (KeyDef.Type.Equals(TEXT("Object"), ESearchCase::IgnoreCase))
{
    FBlackboardEntry Entry;
    Entry.EntryName = FName(*KeyDef.Name);

    UBlackboardKeyType_Object* KeyType = NewObject<UBlackboardKeyType_Object>(BlackboardData);

    // v4.0: Handle custom base class
    if (!KeyDef.BaseClass.IsEmpty())
    {
        UClass* BaseClass = FindObject<UClass>(ANY_PACKAGE, *KeyDef.BaseClass);
        if (!BaseClass)
        {
            // Try common prefixes
            BaseClass = FindObject<UClass>(ANY_PACKAGE, *FString::Printf(TEXT("A%s"), *KeyDef.BaseClass));
        }
        if (!BaseClass)
        {
            BaseClass = FindObject<UClass>(ANY_PACKAGE, *FString::Printf(TEXT("U%s"), *KeyDef.BaseClass));
        }
        if (BaseClass)
        {
            KeyType->BaseClass = BaseClass;
            LogGeneration(Results, EGenerationLogLevel::Info,
                FString::Printf(TEXT("BB %s: Key '%s' base class set to %s"),
                    *Definition.Name, *KeyDef.Name, *BaseClass->GetName()));
        }
        else
        {
            LogGeneration(Results, EGenerationLogLevel::Warning,
                FString::Printf(TEXT("BB %s: Base class '%s' not found for key '%s', using AActor"),
                    *Definition.Name, *KeyDef.BaseClass, *KeyDef.Name));
            KeyType->BaseClass = AActor::StaticClass();
        }
    }
    else
    {
        KeyType->BaseClass = AActor::StaticClass();
    }

    Entry.KeyType = KeyType;
    Entry.bInstanceSynced = KeyDef.bInstanceSynced;

    // v4.0: Set description and category (editor-only)
#if WITH_EDITORONLY_DATA
    if (!KeyDef.Description.IsEmpty())
    {
        Entry.EntryDescription = FString::Printf(TEXT("%s"), *KeyDef.Description);
    }
    if (!KeyDef.Category.IsEmpty())
    {
        Entry.EntryCategory = FName(*KeyDef.Category);
    }
#endif

    BlackboardData->Keys.Add(Entry);
}
else if (KeyDef.Type.Equals(TEXT("Class"), ESearchCase::IgnoreCase))
{
    FBlackboardEntry Entry;
    Entry.EntryName = FName(*KeyDef.Name);

    UBlackboardKeyType_Class* KeyType = NewObject<UBlackboardKeyType_Class>(BlackboardData);

    // v4.0: Handle custom base class
    if (!KeyDef.BaseClass.IsEmpty())
    {
        UClass* BaseClass = FindObject<UClass>(ANY_PACKAGE, *KeyDef.BaseClass);
        if (!BaseClass)
        {
            BaseClass = FindObject<UClass>(ANY_PACKAGE, *FString::Printf(TEXT("A%s"), *KeyDef.BaseClass));
        }
        if (!BaseClass)
        {
            BaseClass = FindObject<UClass>(ANY_PACKAGE, *FString::Printf(TEXT("U%s"), *KeyDef.BaseClass));
        }
        if (BaseClass)
        {
            KeyType->BaseClass = BaseClass;
        }
        else
        {
            KeyType->BaseClass = UObject::StaticClass();
        }
    }
    else
    {
        KeyType->BaseClass = UObject::StaticClass();
    }

    Entry.KeyType = KeyType;
    Entry.bInstanceSynced = KeyDef.bInstanceSynced;

#if WITH_EDITORONLY_DATA
    if (!KeyDef.Description.IsEmpty())
    {
        Entry.EntryDescription = KeyDef.Description;
    }
    if (!KeyDef.Category.IsEmpty())
    {
        Entry.EntryCategory = FName(*KeyDef.Category);
    }
#endif

    BlackboardData->Keys.Add(Entry);
}

// For all other key types, add description/category support:
#if WITH_EDITORONLY_DATA
    if (!KeyDef.Description.IsEmpty())
    {
        Entry.EntryDescription = KeyDef.Description;
    }
    if (!KeyDef.Category.IsEmpty())
    {
        Entry.EntryCategory = FName(*KeyDef.Category);
    }
#endif
```

**Manifest YAML example:**

```yaml
blackboards:
  - name: BB_FatherBase
    folder: AI/Blackboards
    keys:
      - name: OwnerPlayer
        type: Object
        base_class: ANarrativePlayerCharacter
        instance_synced: true
        description: "The player who owns this companion"
        category: Core
      - name: CurrentForm
        type: Enum
        description: "Active Father form"
        category: State

  - name: BB_FatherCombat
    parent: BB_FatherBase  # Inherits OwnerPlayer, CurrentForm
    folder: AI/Blackboards
    keys:
      - name: TargetEnemy
        type: Object
        base_class: ANarrativeCharacter
        instance_synced: true
        description: "Current attack target"
        category: Combat
      - name: LastKnownPosition
        type: Vector
        description: "Last seen position of target"
        category: Combat
      - name: IsInCombat
        type: Bool
        description: "Whether Father is actively fighting"
        category: State
```

---

### 1.3 Float Curve Enhancements (FC_)

**Location:** `GasAbilityGeneratorTypes.h`

**Updated struct definitions:**

```cpp
USTRUCT()
struct FManifestFloatCurveKeyDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    float Time = 0.0f;

    UPROPERTY()
    float Value = 0.0f;

    // NEW v4.0:
    UPROPERTY()
    FString InterpMode;  // Linear, Constant, Cubic, CubicAuto (default: CubicAuto)

    UPROPERTY()
    FString TangentMode;  // Auto, User, Break (default: Auto)

    UPROPERTY()
    float ArriveTangent = 0.0f;  // For User/Break modes

    UPROPERTY()
    float LeaveTangent = 0.0f;   // For User/Break modes

    FString ComputeHash() const
    {
        return FString::Printf(TEXT("%.4f_%.4f_%s_%s_%.4f_%.4f"),
            Time, Value, *InterpMode, *TangentMode, ArriveTangent, LeaveTangent);
    }
};

USTRUCT()
struct FManifestFloatCurveDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    FString Name;

    UPROPERTY()
    FString Folder;

    UPROPERTY()
    TArray<FManifestFloatCurveKeyDefinition> Keys;

    // NEW v4.0:
    UPROPERTY()
    FString PreInfinityExtrap;  // Constant, Linear, Cycle, CycleWithOffset, Oscillate

    UPROPERTY()
    FString PostInfinityExtrap;  // Constant, Linear, Cycle, CycleWithOffset, Oscillate

    UPROPERTY()
    float DefaultValue = 0.0f;  // Value outside curve range

    FString ComputeHash() const
    {
        FString KeysHash;
        for (const FManifestFloatCurveKeyDefinition& Key : Keys)
        {
            KeysHash += Key.ComputeHash();
        }
        return FString::Printf(TEXT("%s_%s_%s_%s_%.4f_%s"),
            *Name, *Folder, *PreInfinityExtrap, *PostInfinityExtrap, DefaultValue, *KeysHash);
    }
};
```

**Parser additions** (in `ParseFloatCurves` function):

```cpp
// At curve level:
else if (Key == TEXT("pre_infinity_extrap") || Key == TEXT("pre_infinity_extrapolation"))
{
    CurrentCurve.PreInfinityExtrap = Value;
}
else if (Key == TEXT("post_infinity_extrap") || Key == TEXT("post_infinity_extrapolation"))
{
    CurrentCurve.PostInfinityExtrap = Value;
}
else if (Key == TEXT("default_value"))
{
    CurrentCurve.DefaultValue = FCString::Atof(*Value);
}

// At key level (when parsing key arrays):
else if (KeyProp == TEXT("interp_mode") || KeyProp == TEXT("interpolation_mode"))
{
    CurrentKey.InterpMode = KeyValue;
}
else if (KeyProp == TEXT("tangent_mode"))
{
    CurrentKey.TangentMode = KeyValue;
}
else if (KeyProp == TEXT("arrive_tangent") || KeyProp == TEXT("tangent_in"))
{
    CurrentKey.ArriveTangent = FCString::Atof(*KeyValue);
}
else if (KeyProp == TEXT("leave_tangent") || KeyProp == TEXT("tangent_out"))
{
    CurrentKey.LeaveTangent = FCString::Atof(*KeyValue);
}
```

**Generator updates** (in `FFloatCurveGenerator::Generate`):

```cpp
// ============================================================================
// FLOAT CURVE GENERATOR v4.0 ENHANCEMENTS
// ============================================================================

// Helper function to convert string to ERichCurveExtrapolation
auto GetExtrapolationMode = [](const FString& Mode) -> ERichCurveExtrapolation
{
    if (Mode.Equals(TEXT("Constant"), ESearchCase::IgnoreCase))
        return RCCE_Constant;
    else if (Mode.Equals(TEXT("Linear"), ESearchCase::IgnoreCase))
        return RCCE_Linear;
    else if (Mode.Equals(TEXT("Cycle"), ESearchCase::IgnoreCase))
        return RCCE_Cycle;
    else if (Mode.Equals(TEXT("CycleWithOffset"), ESearchCase::IgnoreCase))
        return RCCE_CycleWithOffset;
    else if (Mode.Equals(TEXT("Oscillate"), ESearchCase::IgnoreCase))
        return RCCE_Oscillate;
    return RCCE_Constant;  // Default
};

// Helper function to convert string to ERichCurveInterpMode
auto GetInterpMode = [](const FString& Mode) -> ERichCurveInterpMode
{
    if (Mode.Equals(TEXT("Linear"), ESearchCase::IgnoreCase))
        return RCIM_Linear;
    else if (Mode.Equals(TEXT("Constant"), ESearchCase::IgnoreCase))
        return RCIM_Constant;
    else if (Mode.Equals(TEXT("Cubic"), ESearchCase::IgnoreCase) ||
             Mode.Equals(TEXT("CubicAuto"), ESearchCase::IgnoreCase))
        return RCIM_Cubic;
    return RCIM_Cubic;  // Default
};

// Helper function to convert string to ERichCurveTangentMode
auto GetTangentMode = [](const FString& Mode) -> ERichCurveTangentMode
{
    if (Mode.Equals(TEXT("Auto"), ESearchCase::IgnoreCase))
        return RCTM_Auto;
    else if (Mode.Equals(TEXT("User"), ESearchCase::IgnoreCase))
        return RCTM_User;
    else if (Mode.Equals(TEXT("Break"), ESearchCase::IgnoreCase))
        return RCTM_Break;
    else if (Mode.Equals(TEXT("Linear"), ESearchCase::IgnoreCase))
        return RCTM_Auto;  // Linear uses auto tangents
    return RCTM_Auto;  // Default
};

// After creating UCurveFloat:
FRichCurve& RichCurve = CurveFloat->FloatCurve;

// v4.0: Set extrapolation modes
if (!Definition.PreInfinityExtrap.IsEmpty())
{
    RichCurve.PreInfinityExtrap = GetExtrapolationMode(Definition.PreInfinityExtrap);
}

if (!Definition.PostInfinityExtrap.IsEmpty())
{
    RichCurve.PostInfinityExtrap = GetExtrapolationMode(Definition.PostInfinityExtrap);
}

// v4.0: Set default value
if (Definition.DefaultValue != 0.0f)
{
    RichCurve.SetDefaultValue(Definition.DefaultValue);
}

// Add keys with enhanced properties
for (const FManifestFloatCurveKeyDefinition& KeyDef : Definition.Keys)
{
    FKeyHandle KeyHandle = RichCurve.AddKey(KeyDef.Time, KeyDef.Value);

    // v4.0: Set interpolation mode
    if (!KeyDef.InterpMode.IsEmpty())
    {
        RichCurve.SetKeyInterpMode(KeyHandle, GetInterpMode(KeyDef.InterpMode));
    }

    // v4.0: Set tangent mode and values
    if (!KeyDef.TangentMode.IsEmpty())
    {
        ERichCurveTangentMode TangentMode = GetTangentMode(KeyDef.TangentMode);
        RichCurve.SetKeyTangentMode(KeyHandle, TangentMode);

        // If User or Break mode, set custom tangents
        if (TangentMode == RCTM_User || TangentMode == RCTM_Break)
        {
            FRichCurveKey& Key = RichCurve.GetKey(KeyHandle);
            Key.ArriveTangent = KeyDef.ArriveTangent;
            Key.LeaveTangent = KeyDef.LeaveTangent;
        }
    }
}

// Auto-compute tangents for keys using Auto mode
RichCurve.AutoSetTangents();

LogGeneration(Results, EGenerationLogLevel::Info,
    FString::Printf(TEXT("FC %s: Created with %d keys, PreExtrap=%s, PostExtrap=%s"),
        *Definition.Name, Definition.Keys.Num(),
        *Definition.PreInfinityExtrap, *Definition.PostInfinityExtrap));
```

**Manifest YAML example:**

```yaml
float_curves:
  - name: FC_FormTransitionEase
    folder: Curves/Animation
    default_value: 0.0
    pre_infinity_extrap: Constant
    post_infinity_extrap: Constant
    keys:
      - time: 0.0
        value: 0.0
        interp_mode: Cubic
        tangent_mode: Auto
      - time: 0.15
        value: 0.7
        interp_mode: Cubic
        tangent_mode: User
        leave_tangent: 2.0
      - time: 0.5
        value: 0.95
        interp_mode: Cubic
        tangent_mode: Auto
      - time: 1.0
        value: 1.0
        interp_mode: Cubic
        tangent_mode: Auto

  - name: FC_DamageRampUp
    folder: Curves/Combat
    default_value: 1.0
    pre_infinity_extrap: Constant
    post_infinity_extrap: Linear  # Damage continues increasing
    keys:
      - time: 0.0
        value: 0.5
        interp_mode: Linear
      - time: 2.0
        value: 1.0
        interp_mode: Linear
      - time: 5.0
        value: 2.0
        interp_mode: Cubic
        tangent_mode: Auto

  - name: FC_OscillatingGlow
    folder: Curves/VFX
    pre_infinity_extrap: Oscillate  # Ping-pong forever
    post_infinity_extrap: Oscillate
    keys:
      - time: 0.0
        value: 0.2
      - time: 0.5
        value: 1.0
      - time: 1.0
        value: 0.2
```

---

## Phase 2: Behavior Tree Enhancements (BT_)

**This is the most complex enhancement - requires property reflection and tree wiring.**

### 2.1 Updated Struct Definitions

**Location:** `GasAbilityGeneratorTypes.h`

```cpp
USTRUCT()
struct FManifestBTDecoratorDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    FString Class;

    UPROPERTY()
    FString BlackboardKey;

    UPROPERTY()
    FString Operation;  // IsSet, IsNotSet, ValueExists, etc.

    // NEW v4.0:
    UPROPERTY()
    bool bInverseCondition = false;

    UPROPERTY()
    FString FlowAbortMode;  // None, Self, LowerPriority, Both

    UPROPERTY()
    TMap<FString, FString> Properties;  // Generic property bag for reflection

    FString ComputeHash() const
    {
        FString PropsHash;
        for (const auto& Prop : Properties)
        {
            PropsHash += Prop.Key + Prop.Value;
        }
        return FString::Printf(TEXT("%s_%s_%s_%d_%s_%s"),
            *Class, *BlackboardKey, *Operation, bInverseCondition ? 1 : 0, *FlowAbortMode, *PropsHash);
    }
};

USTRUCT()
struct FManifestBTServiceDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    FString Class;

    UPROPERTY()
    float Interval = 0.5f;

    // NEW v4.0:
    UPROPERTY()
    float RandomDeviation = 0.0f;

    UPROPERTY()
    bool bCallTickOnSearchStart = false;

    UPROPERTY()
    bool bRestartTimerOnActivation = true;

    UPROPERTY()
    TMap<FString, FString> Properties;

    FString ComputeHash() const
    {
        FString PropsHash;
        for (const auto& Prop : Properties)
        {
            PropsHash += Prop.Key + Prop.Value;
        }
        return FString::Printf(TEXT("%s_%.4f_%.4f_%d_%d_%s"),
            *Class, Interval, RandomDeviation,
            bCallTickOnSearchStart ? 1 : 0, bRestartTimerOnActivation ? 1 : 0, *PropsHash);
    }
};

USTRUCT()
struct FManifestBTNodeDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    FString Id;

    UPROPERTY()
    FString Type;  // Task, Selector, Sequence, SimpleParallel

    UPROPERTY()
    FString TaskClass;  // For Task type

    UPROPERTY()
    FString BlackboardKey;

    UPROPERTY()
    TArray<FString> Children;  // Child node IDs

    UPROPERTY()
    TArray<FManifestBTDecoratorDefinition> Decorators;

    UPROPERTY()
    TArray<FManifestBTServiceDefinition> Services;

    // NEW v4.0:
    UPROPERTY()
    TMap<FString, FString> Properties;  // Task properties via reflection

    FString ComputeHash() const
    {
        FString ChildrenHash;
        for (const FString& Child : Children)
        {
            ChildrenHash += Child;
        }
        FString DecHash;
        for (const auto& Dec : Decorators)
        {
            DecHash += Dec.ComputeHash();
        }
        FString SvcHash;
        for (const auto& Svc : Services)
        {
            SvcHash += Svc.ComputeHash();
        }
        FString PropsHash;
        for (const auto& Prop : Properties)
        {
            PropsHash += Prop.Key + Prop.Value;
        }
        return FString::Printf(TEXT("%s_%s_%s_%s_%s_%s_%s_%s"),
            *Id, *Type, *TaskClass, *BlackboardKey, *ChildrenHash, *DecHash, *SvcHash, *PropsHash);
    }
};
```

### 2.2 Parser Additions

**Location:** `GasAbilityGeneratorParser.cpp` in `ParseBehaviorTrees`

```cpp
// ============================================================================
// BEHAVIOR TREE PARSER v4.0 ENHANCEMENTS
// ============================================================================

// In decorator parsing section:
else if (DecKey == TEXT("inverse_condition") || DecKey == TEXT("binversecondition"))
{
    CurrentDecorator.bInverseCondition = DecValue.ToBool() ||
        DecValue.Equals(TEXT("true"), ESearchCase::IgnoreCase);
}
else if (DecKey == TEXT("flow_abort_mode") || DecKey == TEXT("flowabortmode"))
{
    CurrentDecorator.FlowAbortMode = DecValue;
}
else if (DecKey == TEXT("properties"))
{
    // Parse property map: { key1: value1, key2: value2 }
    bInDecoratorProperties = true;
}
// In properties sub-parsing:
else if (bInDecoratorProperties)
{
    // Add key-value to properties map
    CurrentDecorator.Properties.Add(DecKey, DecValue);
}

// In service parsing section:
else if (SvcKey == TEXT("random_deviation") || SvcKey == TEXT("randomdeviation"))
{
    CurrentService.RandomDeviation = FCString::Atof(*SvcValue);
}
else if (SvcKey == TEXT("call_tick_on_search_start") || SvcKey == TEXT("bcalltickonssearchstart"))
{
    CurrentService.bCallTickOnSearchStart = SvcValue.ToBool();
}
else if (SvcKey == TEXT("restart_timer_on_activation") || SvcKey == TEXT("brestarttimeronactivation"))
{
    CurrentService.bRestartTimerOnActivation = SvcValue.ToBool();
}
else if (SvcKey == TEXT("properties"))
{
    bInServiceProperties = true;
}
else if (bInServiceProperties)
{
    CurrentService.Properties.Add(SvcKey, SvcValue);
}

// In node parsing section:
else if (NodeKey == TEXT("properties"))
{
    bInNodeProperties = true;
}
else if (bInNodeProperties)
{
    CurrentNode.Properties.Add(NodeKey, NodeValue);
}
else if (NodeKey == TEXT("children"))
{
    // Parse children array: [Child1, Child2, Child3]
    FString ChildrenStr = NodeValue;
    ChildrenStr.RemoveFromStart(TEXT("["));
    ChildrenStr.RemoveFromEnd(TEXT("]"));
    TArray<FString> ChildIds;
    ChildrenStr.ParseIntoArray(ChildIds, TEXT(","));
    for (FString& ChildId : ChildIds)
    {
        ChildId.TrimStartAndEndInline();
        CurrentNode.Children.Add(ChildId);
    }
}
```

### 2.3 Generator Updates

**Location:** `GasAbilityGeneratorGenerators.cpp` in `FBehaviorTreeGenerator::Generate`

```cpp
// ============================================================================
// BEHAVIOR TREE GENERATOR v4.0 ENHANCEMENTS
// ============================================================================

// Helper: Convert FlowAbortMode string to enum
auto GetFlowAbortMode = [](const FString& Mode) -> EBTFlowAbortMode::Type
{
    if (Mode.Equals(TEXT("None"), ESearchCase::IgnoreCase))
        return EBTFlowAbortMode::None;
    else if (Mode.Equals(TEXT("Self"), ESearchCase::IgnoreCase))
        return EBTFlowAbortMode::Self;
    else if (Mode.Equals(TEXT("LowerPriority"), ESearchCase::IgnoreCase))
        return EBTFlowAbortMode::LowerPriority;
    else if (Mode.Equals(TEXT("Both"), ESearchCase::IgnoreCase))
        return EBTFlowAbortMode::Both;
    return EBTFlowAbortMode::None;
};

// Helper: Set property via reflection (reuse pattern from Quest generator)
auto SetPropertyByReflection = [&](UObject* Object, const FString& PropName, const FString& PropValue) -> bool
{
    if (!Object) return false;

    FProperty* Property = Object->GetClass()->FindPropertyByName(FName(*PropName));
    if (!Property)
    {
        // Try with 'b' prefix for bools
        Property = Object->GetClass()->FindPropertyByName(FName(*FString::Printf(TEXT("b%s"), *PropName)));
    }
    if (!Property)
    {
        // Try common variations
        FString AltName = PropName;
        AltName.ReplaceInline(TEXT("_"), TEXT(""));  // Remove underscores
        Property = Object->GetClass()->FindPropertyByName(FName(*AltName));
    }

    if (!Property)
    {
        LogGeneration(Results, EGenerationLogLevel::Warning,
            FString::Printf(TEXT("BT: Property '%s' not found on %s"), *PropName, *Object->GetClass()->GetName()));
        return false;
    }

    void* ValuePtr = Property->ContainerPtrToValuePtr<void>(Object);

    if (FBoolProperty* BoolProp = CastField<FBoolProperty>(Property))
    {
        BoolProp->SetPropertyValue(ValuePtr, PropValue.ToBool() || PropValue.Equals(TEXT("true"), ESearchCase::IgnoreCase));
        return true;
    }
    else if (FFloatProperty* FloatProp = CastField<FFloatProperty>(Property))
    {
        FloatProp->SetPropertyValue(ValuePtr, FCString::Atof(*PropValue));
        return true;
    }
    else if (FDoubleProperty* DoubleProp = CastField<FDoubleProperty>(Property))
    {
        DoubleProp->SetPropertyValue(ValuePtr, FCString::Atod(*PropValue));
        return true;
    }
    else if (FIntProperty* IntProp = CastField<FIntProperty>(Property))
    {
        IntProp->SetPropertyValue(ValuePtr, FCString::Atoi(*PropValue));
        return true;
    }
    else if (FStrProperty* StrProp = CastField<FStrProperty>(Property))
    {
        StrProp->SetPropertyValue(ValuePtr, PropValue);
        return true;
    }
    else if (FNameProperty* NameProp = CastField<FNameProperty>(Property))
    {
        NameProp->SetPropertyValue(ValuePtr, FName(*PropValue));
        return true;
    }

    return false;
};

// Build node map for child wiring
TMap<FString, UBTNode*> NodeMap;

// First pass: Create all nodes
for (const FManifestBTNodeDefinition& NodeDef : Definition.Nodes)
{
    UBTNode* CreatedNode = nullptr;

    if (NodeDef.Type.Equals(TEXT("Task"), ESearchCase::IgnoreCase))
    {
        // Find task class
        UClass* TaskClass = FindObject<UClass>(ANY_PACKAGE, *NodeDef.TaskClass);
        if (!TaskClass)
        {
            TaskClass = FindObject<UClass>(ANY_PACKAGE, *FString::Printf(TEXT("UBTTask_%s"), *NodeDef.TaskClass));
        }
        if (!TaskClass)
        {
            TaskClass = LoadClass<UBTTaskNode>(nullptr, *FString::Printf(TEXT("/Script/AIModule.BTTask_%s"), *NodeDef.TaskClass));
        }

        if (TaskClass && TaskClass->IsChildOf(UBTTaskNode::StaticClass()))
        {
            UBTTaskNode* TaskNode = NewObject<UBTTaskNode>(BehaviorTree, TaskClass);

            // v4.0: Apply properties via reflection
            for (const auto& Prop : NodeDef.Properties)
            {
                SetPropertyByReflection(TaskNode, Prop.Key, Prop.Value);
            }

            // Set blackboard key if specified
            if (!NodeDef.BlackboardKey.IsEmpty())
            {
                // Try to find and set blackboard key selector property
                FProperty* BBKeyProp = TaskClass->FindPropertyByName(TEXT("BlackboardKey"));
                if (!BBKeyProp) BBKeyProp = TaskClass->FindPropertyByName(TEXT("TargetBlackboardKey"));
                if (!BBKeyProp) BBKeyProp = TaskClass->FindPropertyByName(TEXT("EnemyKey"));

                if (BBKeyProp)
                {
                    if (FStructProperty* StructProp = CastField<FStructProperty>(BBKeyProp))
                    {
                        if (StructProp->Struct->GetFName() == TEXT("BlackboardKeySelector"))
                        {
                            FBlackboardKeySelector* Selector = StructProp->ContainerPtrToValuePtr<FBlackboardKeySelector>(TaskNode);
                            Selector->SelectedKeyName = FName(*NodeDef.BlackboardKey);
                        }
                    }
                }
            }

            CreatedNode = TaskNode;
        }
    }
    else if (NodeDef.Type.Equals(TEXT("Selector"), ESearchCase::IgnoreCase))
    {
        UBTComposite_Selector* SelectorNode = NewObject<UBTComposite_Selector>(BehaviorTree);
        CreatedNode = SelectorNode;
    }
    else if (NodeDef.Type.Equals(TEXT("Sequence"), ESearchCase::IgnoreCase))
    {
        UBTComposite_Sequence* SequenceNode = NewObject<UBTComposite_Sequence>(BehaviorTree);
        CreatedNode = SequenceNode;
    }
    else if (NodeDef.Type.Equals(TEXT("SimpleParallel"), ESearchCase::IgnoreCase))
    {
        UBTComposite_SimpleParallel* ParallelNode = NewObject<UBTComposite_SimpleParallel>(BehaviorTree);
        CreatedNode = ParallelNode;
    }

    if (CreatedNode)
    {
        NodeMap.Add(NodeDef.Id, CreatedNode);

        // v4.0: Create and attach decorators
        for (const FManifestBTDecoratorDefinition& DecDef : NodeDef.Decorators)
        {
            UClass* DecClass = FindObject<UClass>(ANY_PACKAGE, *DecDef.Class);
            if (!DecClass)
            {
                DecClass = LoadClass<UBTDecorator>(nullptr, *FString::Printf(TEXT("/Script/AIModule.%s"), *DecDef.Class));
            }

            if (DecClass && DecClass->IsChildOf(UBTDecorator::StaticClass()))
            {
                UBTDecorator* Decorator = NewObject<UBTDecorator>(BehaviorTree, DecClass);

                // Set inverse condition
                if (DecDef.bInverseCondition)
                {
                    FBoolProperty* InverseProp = CastField<FBoolProperty>(
                        DecClass->FindPropertyByName(TEXT("bInverseCondition")));
                    if (InverseProp)
                    {
                        InverseProp->SetPropertyValue(
                            InverseProp->ContainerPtrToValuePtr<void>(Decorator), true);
                    }
                }

                // Set flow abort mode
                if (!DecDef.FlowAbortMode.IsEmpty())
                {
                    FByteProperty* AbortProp = CastField<FByteProperty>(
                        DecClass->FindPropertyByName(TEXT("FlowAbortMode")));
                    if (AbortProp)
                    {
                        AbortProp->SetPropertyValue(
                            AbortProp->ContainerPtrToValuePtr<void>(Decorator),
                            (uint8)GetFlowAbortMode(DecDef.FlowAbortMode));
                    }
                }

                // Set blackboard key
                if (!DecDef.BlackboardKey.IsEmpty())
                {
                    FProperty* BBKeyProp = DecClass->FindPropertyByName(TEXT("BlackboardKey"));
                    if (BBKeyProp)
                    {
                        if (FStructProperty* StructProp = CastField<FStructProperty>(BBKeyProp))
                        {
                            if (StructProp->Struct->GetFName() == TEXT("BlackboardKeySelector"))
                            {
                                FBlackboardKeySelector* Selector =
                                    StructProp->ContainerPtrToValuePtr<FBlackboardKeySelector>(Decorator);
                                Selector->SelectedKeyName = FName(*DecDef.BlackboardKey);
                            }
                        }
                    }
                }

                // Apply custom properties
                for (const auto& Prop : DecDef.Properties)
                {
                    SetPropertyByReflection(Decorator, Prop.Key, Prop.Value);
                }

                // Attach decorator to node
                if (UBTCompositeNode* CompositeNode = Cast<UBTCompositeNode>(CreatedNode))
                {
                    CompositeNode->Decorators.Add(Decorator);
                }
                else if (UBTTaskNode* TaskNode = Cast<UBTTaskNode>(CreatedNode))
                {
                    TaskNode->Decorators.Add(Decorator);
                }
            }
        }

        // v4.0: Create and attach services
        for (const FManifestBTServiceDefinition& SvcDef : NodeDef.Services)
        {
            UClass* SvcClass = FindObject<UClass>(ANY_PACKAGE, *SvcDef.Class);
            if (!SvcClass)
            {
                SvcClass = LoadClass<UBTService>(nullptr, *FString::Printf(TEXT("/Script/AIModule.%s"), *SvcDef.Class));
            }

            if (SvcClass && SvcClass->IsChildOf(UBTService::StaticClass()))
            {
                UBTService* Service = NewObject<UBTService>(BehaviorTree, SvcClass);

                // Set interval
                FFloatProperty* IntervalProp = CastField<FFloatProperty>(
                    SvcClass->FindPropertyByName(TEXT("Interval")));
                if (IntervalProp)
                {
                    IntervalProp->SetPropertyValue(
                        IntervalProp->ContainerPtrToValuePtr<void>(Service), SvcDef.Interval);
                }

                // Set random deviation
                FFloatProperty* DeviationProp = CastField<FFloatProperty>(
                    SvcClass->FindPropertyByName(TEXT("RandomDeviation")));
                if (DeviationProp)
                {
                    DeviationProp->SetPropertyValue(
                        DeviationProp->ContainerPtrToValuePtr<void>(Service), SvcDef.RandomDeviation);
                }

                // Set tick on search start
                FBoolProperty* TickStartProp = CastField<FBoolProperty>(
                    SvcClass->FindPropertyByName(TEXT("bCallTickOnSearchStart")));
                if (TickStartProp)
                {
                    TickStartProp->SetPropertyValue(
                        TickStartProp->ContainerPtrToValuePtr<void>(Service), SvcDef.bCallTickOnSearchStart);
                }

                // Set restart timer
                FBoolProperty* RestartProp = CastField<FBoolProperty>(
                    SvcClass->FindPropertyByName(TEXT("bRestartTimerOnEachActivation")));
                if (RestartProp)
                {
                    RestartProp->SetPropertyValue(
                        RestartProp->ContainerPtrToValuePtr<void>(Service), SvcDef.bRestartTimerOnActivation);
                }

                // Apply custom properties
                for (const auto& Prop : SvcDef.Properties)
                {
                    SetPropertyByReflection(Service, Prop.Key, Prop.Value);
                }

                // Attach service to node
                if (UBTCompositeNode* CompositeNode = Cast<UBTCompositeNode>(CreatedNode))
                {
                    CompositeNode->Services.Add(Service);
                }
                else if (UBTTaskNode* TaskNode = Cast<UBTTaskNode>(CreatedNode))
                {
                    TaskNode->Services.Add(Service);
                }
            }
        }
    }
}

// Second pass: Wire parent-child relationships
for (const FManifestBTNodeDefinition& NodeDef : Definition.Nodes)
{
    if (NodeDef.Children.Num() == 0) continue;

    UBTNode** ParentNodePtr = NodeMap.Find(NodeDef.Id);
    if (!ParentNodePtr) continue;

    UBTCompositeNode* ParentComposite = Cast<UBTCompositeNode>(*ParentNodePtr);
    if (!ParentComposite)
    {
        LogGeneration(Results, EGenerationLogLevel::Warning,
            FString::Printf(TEXT("BT %s: Node '%s' has children but is not a composite node"),
                *Definition.Name, *NodeDef.Id));
        continue;
    }

    for (const FString& ChildId : NodeDef.Children)
    {
        UBTNode** ChildNodePtr = NodeMap.Find(ChildId);
        if (!ChildNodePtr)
        {
            LogGeneration(Results, EGenerationLogLevel::Warning,
                FString::Printf(TEXT("BT %s: Child node '%s' not found for parent '%s'"),
                    *Definition.Name, *ChildId, *NodeDef.Id));
            continue;
        }

        // Create child slot
        FBTCompositeChild ChildSlot;
        ChildSlot.ChildComposite = Cast<UBTCompositeNode>(*ChildNodePtr);
        ChildSlot.ChildTask = Cast<UBTTaskNode>(*ChildNodePtr);

        // Copy decorators from child to slot
        if (ChildSlot.ChildComposite)
        {
            ChildSlot.Decorators = ChildSlot.ChildComposite->Decorators;
        }
        else if (ChildSlot.ChildTask)
        {
            ChildSlot.Decorators = ChildSlot.ChildTask->Decorators;
        }

        ParentComposite->Children.Add(ChildSlot);

        LogGeneration(Results, EGenerationLogLevel::Info,
            FString::Printf(TEXT("BT %s: Wired child '%s' to parent '%s'"),
                *Definition.Name, *ChildId, *NodeDef.Id));
    }
}

// Set root node (first Selector/Sequence in manifest, or explicit root)
if (NodeMap.Num() > 0)
{
    // Find root node (look for node named "Root" or first composite)
    UBTNode** RootPtr = NodeMap.Find(TEXT("Root"));
    if (!RootPtr)
    {
        // Use first defined composite node
        for (const FManifestBTNodeDefinition& NodeDef : Definition.Nodes)
        {
            if (NodeDef.Type.Equals(TEXT("Selector"), ESearchCase::IgnoreCase) ||
                NodeDef.Type.Equals(TEXT("Sequence"), ESearchCase::IgnoreCase))
            {
                RootPtr = NodeMap.Find(NodeDef.Id);
                break;
            }
        }
    }

    if (RootPtr && Cast<UBTCompositeNode>(*RootPtr))
    {
        BehaviorTree->RootNode = Cast<UBTCompositeNode>(*RootPtr);
        LogGeneration(Results, EGenerationLogLevel::Info,
            FString::Printf(TEXT("BT %s: Set root node"), *Definition.Name));
    }
}
```

### 2.4 Manifest YAML Example

```yaml
behavior_trees:
  - name: BT_FatherCombat
    blackboard: BB_Father
    folder: AI/BehaviorTrees
    root_type: Selector
    nodes:
      # Root selector - chooses between combat and idle
      - id: Root
        type: Selector
        children: [CombatSequence, IdleSequence]
        services:
          - class: BTS_UpdatePerception
            interval: 0.25
            random_deviation: 0.05

      # Combat branch
      - id: CombatSequence
        type: Sequence
        children: [ValidateTarget, MoveToTarget, AttackTarget]
        decorators:
          - class: BTDecorator_Blackboard
            blackboard_key: TargetEnemy
            operation: IsSet
            flow_abort_mode: Both

      - id: ValidateTarget
        type: Task
        task_class: BTTask_CheckCondition
        properties:
          condition_tag: Father.State.Alive

      - id: MoveToTarget
        type: Task
        task_class: BTTask_MoveTo
        blackboard_key: TargetEnemy
        properties:
          acceptable_radius: 150.0
          allow_strafe: true
          allow_partial_path: true
        decorators:
          - class: BTDecorator_IsAtLocation
            blackboard_key: TargetEnemy
            inverse_condition: true  # Only move if NOT at location
            flow_abort_mode: Self
            properties:
              acceptable_radius: 150.0

      - id: AttackTarget
        type: Task
        task_class: BTTask_ActivateAbilityByClass
        properties:
          ability_class: GA_FatherAttack
        services:
          - class: BTS_SetFocus
            interval: 0.1
            call_tick_on_search_start: true

      # Idle branch
      - id: IdleSequence
        type: Sequence
        children: [WaitRandom, LookAround]

      - id: WaitRandom
        type: Task
        task_class: BTTask_Wait
        properties:
          wait_time: 2.0
          random_deviation: 1.0

      - id: LookAround
        type: Task
        task_class: BTTask_RotateToFaceBBEntry
        blackboard_key: OwnerPlayer
```

---

## Phase 3: Material Enhancements (M_)

### 3.1 Updated Struct Definitions

**Location:** `GasAbilityGeneratorTypes.h`

```cpp
USTRUCT()
struct FManifestMaterialExpressionDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    FString Id;

    UPROPERTY()
    FString Type;  // ScalarParam, VectorParam, TextureSample, TextureSampleParameter2D, etc.

    UPROPERTY()
    TMap<FString, FString> Properties;

    UPROPERTY()
    float PosX = 0.0f;

    UPROPERTY()
    float PosY = 0.0f;

    // NEW v4.0 - Texture specific:
    UPROPERTY()
    FString TexturePath;  // "/Game/Textures/T_Fire"

    UPROPERTY()
    FString SamplerType;  // Color, LinearColor, Normal, Masks, Grayscale, Alpha, DistanceFieldFont

    FString ComputeHash() const
    {
        FString PropsHash;
        for (const auto& Prop : Properties)
        {
            PropsHash += Prop.Key + Prop.Value;
        }
        return FString::Printf(TEXT("%s_%s_%.2f_%.2f_%s_%s_%s"),
            *Id, *Type, PosX, PosY, *PropsHash, *TexturePath, *SamplerType);
    }
};

USTRUCT()
struct FManifestMaterialDefinition
{
    GENERATED_BODY()

    UPROPERTY()
    FString Name;

    UPROPERTY()
    FString Folder;

    UPROPERTY()
    FString BlendMode;  // Opaque, Masked, Translucent, Additive, Modulate

    UPROPERTY()
    FString ShadingModel;  // DefaultLit, Unlit, Subsurface, ClearCoat, SubsurfaceProfile, TwoSidedFoliage, Hair, Cloth, Eye, SingleLayerWater, ThinTranslucent

    UPROPERTY()
    bool bTwoSided = false;

    // NEW v4.0 - Material Domain:
    UPROPERTY()
    FString MaterialDomain;  // Surface, DeferredDecal, LightFunction, Volume, PostProcess, UI

    // NEW v4.0 - Culling:
    UPROPERTY()
    FString CullMode;  // None, Front, Back

    // NEW v4.0 - Masking:
    UPROPERTY()
    float OpacityMaskClipValue = 0.333f;

    // NEW v4.0 - Translucency:
    UPROPERTY()
    FString TranslucencyPass;  // BeforeDOF, AfterDOF, AfterMotionBlur

    UPROPERTY()
    bool bEnableSeparateTranslucency = false;

    UPROPERTY()
    bool bEnableResponsiveAA = false;

    // NEW v4.0 - Decals:
    UPROPERTY()
    FString DecalResponse;  // None, Color, Normal, ColorNormalRoughness, etc.

    // NEW v4.0 - Lighting:
    UPROPERTY()
    bool bCastDynamicShadow = true;

    UPROPERTY()
    bool bAffectDynamicIndirectLighting = true;

    UPROPERTY()
    bool bBlockGI = false;

    UPROPERTY()
    bool bUseEmissiveForDynamicAreaLights = false;

    // NEW v4.0 - Advanced:
    UPROPERTY()
    bool bTangentSpaceNormal = true;

    UPROPERTY()
    bool bUseFullPrecision = false;

    UPROPERTY()
    bool bForceFullyRough = false;

    // NEW v4.0 - Nanite (UE5):
    UPROPERTY()
    bool bUseNaniteDisplacement = false;

    UPROPERTY()
    bool bAutoGenerateNaniteDistanceField = false;

    // Existing:
    UPROPERTY()
    TArray<FManifestMaterialExpressionDefinition> Expressions;

    UPROPERTY()
    TArray<FManifestMaterialConnectionDefinition> Connections;

    FString ComputeHash() const
    {
        // Include all new fields in hash
        FString ExprHash;
        for (const auto& Expr : Expressions)
        {
            ExprHash += Expr.ComputeHash();
        }
        FString ConnHash;
        for (const auto& Conn : Connections)
        {
            ConnHash += Conn.ComputeHash();
        }
        return FString::Printf(TEXT("%s_%s_%s_%s_%d_%s_%s_%.4f_%s_%d_%d_%s_%d_%d_%d_%d_%d_%d_%d_%d_%d_%s_%s"),
            *Name, *Folder, *BlendMode, *ShadingModel, bTwoSided ? 1 : 0,
            *MaterialDomain, *CullMode, OpacityMaskClipValue,
            *TranslucencyPass, bEnableSeparateTranslucency ? 1 : 0, bEnableResponsiveAA ? 1 : 0,
            *DecalResponse, bCastDynamicShadow ? 1 : 0, bAffectDynamicIndirectLighting ? 1 : 0,
            bBlockGI ? 1 : 0, bUseEmissiveForDynamicAreaLights ? 1 : 0,
            bTangentSpaceNormal ? 1 : 0, bUseFullPrecision ? 1 : 0, bForceFullyRough ? 1 : 0,
            bUseNaniteDisplacement ? 1 : 0, bAutoGenerateNaniteDistanceField ? 1 : 0,
            *ExprHash, *ConnHash);
    }
};
```

### 3.2 Parser Additions

**Location:** `GasAbilityGeneratorParser.cpp` in `ParseMaterials`

```cpp
// ============================================================================
// MATERIAL PARSER v4.0 ENHANCEMENTS
// ============================================================================

// At material level:
else if (Key == TEXT("material_domain"))
{
    CurrentMaterial.MaterialDomain = Value;
}
else if (Key == TEXT("cull_mode"))
{
    CurrentMaterial.CullMode = Value;
}
else if (Key == TEXT("opacity_mask_clip_value"))
{
    CurrentMaterial.OpacityMaskClipValue = FCString::Atof(*Value);
}
else if (Key == TEXT("translucency_pass"))
{
    CurrentMaterial.TranslucencyPass = Value;
}
else if (Key == TEXT("separate_translucency") || Key == TEXT("enable_separate_translucency"))
{
    CurrentMaterial.bEnableSeparateTranslucency = Value.ToBool();
}
else if (Key == TEXT("responsive_aa") || Key == TEXT("enable_responsive_aa"))
{
    CurrentMaterial.bEnableResponsiveAA = Value.ToBool();
}
else if (Key == TEXT("decal_response"))
{
    CurrentMaterial.DecalResponse = Value;
}
else if (Key == TEXT("cast_dynamic_shadow"))
{
    CurrentMaterial.bCastDynamicShadow = Value.ToBool();
}
else if (Key == TEXT("affect_dynamic_indirect_lighting"))
{
    CurrentMaterial.bAffectDynamicIndirectLighting = Value.ToBool();
}
else if (Key == TEXT("block_gi"))
{
    CurrentMaterial.bBlockGI = Value.ToBool();
}
else if (Key == TEXT("use_emissive_for_dynamic_area_lights"))
{
    CurrentMaterial.bUseEmissiveForDynamicAreaLights = Value.ToBool();
}
else if (Key == TEXT("tangent_space_normal"))
{
    CurrentMaterial.bTangentSpaceNormal = Value.ToBool();
}
else if (Key == TEXT("use_full_precision"))
{
    CurrentMaterial.bUseFullPrecision = Value.ToBool();
}
else if (Key == TEXT("force_fully_rough"))
{
    CurrentMaterial.bForceFullyRough = Value.ToBool();
}
else if (Key == TEXT("use_nanite_displacement"))
{
    CurrentMaterial.bUseNaniteDisplacement = Value.ToBool();
}
else if (Key == TEXT("auto_generate_nanite_distance_field"))
{
    CurrentMaterial.bAutoGenerateNaniteDistanceField = Value.ToBool();
}

// In expression parsing:
else if (ExprKey == TEXT("texture_path"))
{
    CurrentExpression.TexturePath = ExprValue;
}
else if (ExprKey == TEXT("sampler_type"))
{
    CurrentExpression.SamplerType = ExprValue;
}
```

### 3.3 Generator Updates

**Location:** `GasAbilityGeneratorGenerators.cpp` in `FMaterialGenerator::Generate`

```cpp
// ============================================================================
// MATERIAL GENERATOR v4.0 ENHANCEMENTS
// ============================================================================

// Helper: Convert MaterialDomain string to enum
auto GetMaterialDomain = [](const FString& Domain) -> EMaterialDomain
{
    if (Domain.Equals(TEXT("Surface"), ESearchCase::IgnoreCase))
        return MD_Surface;
    else if (Domain.Equals(TEXT("DeferredDecal"), ESearchCase::IgnoreCase))
        return MD_DeferredDecal;
    else if (Domain.Equals(TEXT("LightFunction"), ESearchCase::IgnoreCase))
        return MD_LightFunction;
    else if (Domain.Equals(TEXT("Volume"), ESearchCase::IgnoreCase))
        return MD_Volume;
    else if (Domain.Equals(TEXT("PostProcess"), ESearchCase::IgnoreCase))
        return MD_PostProcess;
    else if (Domain.Equals(TEXT("UI"), ESearchCase::IgnoreCase))
        return MD_UI;
    return MD_Surface;
};

// Helper: Convert SamplerType string to enum
auto GetSamplerType = [](const FString& Type) -> EMaterialSamplerType
{
    if (Type.Equals(TEXT("Color"), ESearchCase::IgnoreCase))
        return SAMPLERTYPE_Color;
    else if (Type.Equals(TEXT("LinearColor"), ESearchCase::IgnoreCase))
        return SAMPLERTYPE_LinearColor;
    else if (Type.Equals(TEXT("Normal"), ESearchCase::IgnoreCase))
        return SAMPLERTYPE_Normal;
    else if (Type.Equals(TEXT("Masks"), ESearchCase::IgnoreCase))
        return SAMPLERTYPE_Masks;
    else if (Type.Equals(TEXT("Grayscale"), ESearchCase::IgnoreCase))
        return SAMPLERTYPE_Grayscale;
    else if (Type.Equals(TEXT("Alpha"), ESearchCase::IgnoreCase))
        return SAMPLERTYPE_Alpha;
    else if (Type.Equals(TEXT("DistanceFieldFont"), ESearchCase::IgnoreCase))
        return SAMPLERTYPE_DistanceFieldFont;
    return SAMPLERTYPE_Color;
};

// After setting existing material properties, add:

// v4.0: Set material domain
if (!Definition.MaterialDomain.IsEmpty())
{
    Material->MaterialDomain = GetMaterialDomain(Definition.MaterialDomain);
}

// v4.0: Set cull mode (backface culling)
if (!Definition.CullMode.IsEmpty())
{
    if (Definition.CullMode.Equals(TEXT("None"), ESearchCase::IgnoreCase))
    {
        Material->bTwoSided = true;  // No culling = two-sided
    }
    // Note: UE5 doesn't have a direct CullMode property on UMaterial
    // CullMode is typically set through mesh or material instance
}

// v4.0: Set opacity mask clip value
if (Definition.BlendMode.Equals(TEXT("Masked"), ESearchCase::IgnoreCase))
{
    Material->OpacityMaskClipValue = Definition.OpacityMaskClipValue;
}

// v4.0: Set translucency settings
if (!Definition.TranslucencyPass.IsEmpty())
{
    if (Definition.TranslucencyPass.Equals(TEXT("BeforeDOF"), ESearchCase::IgnoreCase))
        Material->TranslucencyPass = MTP_BeforeDOF;
    else if (Definition.TranslucencyPass.Equals(TEXT("AfterDOF"), ESearchCase::IgnoreCase))
        Material->TranslucencyPass = MTP_AfterDOF;
    else if (Definition.TranslucencyPass.Equals(TEXT("AfterMotionBlur"), ESearchCase::IgnoreCase))
        Material->TranslucencyPass = MTP_AfterMotionBlur;
}

Material->bEnableSeparateTranslucency = Definition.bEnableSeparateTranslucency;
Material->bEnableResponsiveAA = Definition.bEnableResponsiveAA;

// v4.0: Set decal response
if (!Definition.DecalResponse.IsEmpty())
{
    if (Definition.DecalResponse.Equals(TEXT("None"), ESearchCase::IgnoreCase))
        Material->MaterialDecalResponse = MDR_None;
    else if (Definition.DecalResponse.Equals(TEXT("ColorNormalRoughness"), ESearchCase::IgnoreCase))
        Material->MaterialDecalResponse = MDR_ColorNormalRoughness;
    else if (Definition.DecalResponse.Equals(TEXT("Color"), ESearchCase::IgnoreCase))
        Material->MaterialDecalResponse = MDR_Color;
    else if (Definition.DecalResponse.Equals(TEXT("ColorNormal"), ESearchCase::IgnoreCase))
        Material->MaterialDecalResponse = MDR_ColorNormal;
    else if (Definition.DecalResponse.Equals(TEXT("ColorRoughness"), ESearchCase::IgnoreCase))
        Material->MaterialDecalResponse = MDR_ColorRoughness;
    else if (Definition.DecalResponse.Equals(TEXT("Normal"), ESearchCase::IgnoreCase))
        Material->MaterialDecalResponse = MDR_Normal;
    else if (Definition.DecalResponse.Equals(TEXT("NormalRoughness"), ESearchCase::IgnoreCase))
        Material->MaterialDecalResponse = MDR_NormalRoughness;
    else if (Definition.DecalResponse.Equals(TEXT("Roughness"), ESearchCase::IgnoreCase))
        Material->MaterialDecalResponse = MDR_Roughness;
}

// v4.0: Set lighting properties
Material->bCastDynamicShadowAsMasked = Definition.bCastDynamicShadow;
Material->bAffectDynamicIndirectLighting = Definition.bAffectDynamicIndirectLighting;
Material->bBlockGI = Definition.bBlockGI;
Material->bUseEmissiveForDynamicAreaLighting = Definition.bUseEmissiveForDynamicAreaLights;

// v4.0: Set advanced properties
Material->bTangentSpaceNormal = Definition.bTangentSpaceNormal;
Material->bFullyRough = Definition.bForceFullyRough;
Material->bUseFullPrecision = Definition.bUseFullPrecision;

// v4.0: Set Nanite properties (UE5.7+)
#if ENGINE_MAJOR_VERSION >= 5
Material->bUseNaniteDisplacement = Definition.bUseNaniteDisplacement;
// Note: bAutoGenerateNaniteDistanceField may require additional property access
#endif

// In expression creation, add TextureSample support:
// Find the CreateExpression helper and add:

else if (ExprDef.Type.Equals(TEXT("TextureSample"), ESearchCase::IgnoreCase))
{
    UMaterialExpressionTextureSample* TextureExpr =
        NewObject<UMaterialExpressionTextureSample>(Material);

    // Load texture asset
    if (!ExprDef.TexturePath.IsEmpty())
    {
        UTexture* Texture = LoadObject<UTexture>(nullptr, *ExprDef.TexturePath);
        if (Texture)
        {
            TextureExpr->Texture = Texture;
        }
        else
        {
            LogGeneration(Results, EGenerationLogLevel::Warning,
                FString::Printf(TEXT("M %s: Texture '%s' not found for expression '%s'"),
                    *Definition.Name, *ExprDef.TexturePath, *ExprDef.Id));
        }
    }

    // Set sampler type
    if (!ExprDef.SamplerType.IsEmpty())
    {
        TextureExpr->SamplerType = GetSamplerType(ExprDef.SamplerType);
    }

    TextureExpr->MaterialExpressionEditorX = ExprDef.PosX;
    TextureExpr->MaterialExpressionEditorY = ExprDef.PosY;
    TextureExpr->Desc = ExprDef.Id;

    Material->GetExpressionCollection().Expressions.Add(TextureExpr);
    ExpressionMap.Add(ExprDef.Id, TextureExpr);
}
else if (ExprDef.Type.Equals(TEXT("TextureSampleParameter2D"), ESearchCase::IgnoreCase) ||
         ExprDef.Type.Equals(TEXT("TextureParam"), ESearchCase::IgnoreCase))
{
    UMaterialExpressionTextureSampleParameter2D* TextureParamExpr =
        NewObject<UMaterialExpressionTextureSampleParameter2D>(Material);

    // Set parameter name
    const FString* ParamName = ExprDef.Properties.Find(TEXT("parameter_name"));
    if (ParamName)
    {
        TextureParamExpr->ParameterName = FName(**ParamName);
    }
    else
    {
        TextureParamExpr->ParameterName = FName(*ExprDef.Id);
    }

    // Load default texture
    if (!ExprDef.TexturePath.IsEmpty())
    {
        UTexture* Texture = LoadObject<UTexture>(nullptr, *ExprDef.TexturePath);
        if (Texture)
        {
            TextureParamExpr->Texture = Texture;
        }
    }

    // Set sampler type
    if (!ExprDef.SamplerType.IsEmpty())
    {
        TextureParamExpr->SamplerType = GetSamplerType(ExprDef.SamplerType);
    }

    // Set group (for material instances)
    const FString* Group = ExprDef.Properties.Find(TEXT("group"));
    if (Group)
    {
        TextureParamExpr->Group = FName(**Group);
    }

    TextureParamExpr->MaterialExpressionEditorX = ExprDef.PosX;
    TextureParamExpr->MaterialExpressionEditorY = ExprDef.PosY;
    TextureParamExpr->Desc = ExprDef.Id;

    Material->GetExpressionCollection().Expressions.Add(TextureParamExpr);
    ExpressionMap.Add(ExprDef.Id, TextureParamExpr);
}
else if (ExprDef.Type.Equals(TEXT("TextureObject"), ESearchCase::IgnoreCase))
{
    UMaterialExpressionTextureObject* TextureObjExpr =
        NewObject<UMaterialExpressionTextureObject>(Material);

    if (!ExprDef.TexturePath.IsEmpty())
    {
        UTexture* Texture = LoadObject<UTexture>(nullptr, *ExprDef.TexturePath);
        if (Texture)
        {
            TextureObjExpr->Texture = Texture;
        }
    }

    if (!ExprDef.SamplerType.IsEmpty())
    {
        TextureObjExpr->SamplerType = GetSamplerType(ExprDef.SamplerType);
    }

    TextureObjExpr->MaterialExpressionEditorX = ExprDef.PosX;
    TextureObjExpr->MaterialExpressionEditorY = ExprDef.PosY;
    TextureObjExpr->Desc = ExprDef.Id;

    Material->GetExpressionCollection().Expressions.Add(TextureObjExpr);
    ExpressionMap.Add(ExprDef.Id, TextureObjExpr);
}
```

### 3.4 Manifest YAML Example

```yaml
materials:
  - name: M_FatherEnergyShield
    folder: Materials/Father/VFX
    blend_mode: Translucent
    shading_model: Unlit
    two_sided: true
    # v4.0 properties:
    material_domain: Surface
    opacity_mask_clip_value: 0.5
    translucency_pass: AfterDOF
    separate_translucency: true
    responsive_aa: true
    decal_response: None
    cast_dynamic_shadow: false
    affect_dynamic_indirect_lighting: false
    use_emissive_for_dynamic_area_lights: true
    tangent_space_normal: true
    expressions:
      # Texture sampling
      - id: EnergyPattern
        type: TextureSampleParameter2D
        texture_path: /Game/Textures/T_EnergyPattern
        sampler_type: Color
        properties:
          parameter_name: PatternTexture
          group: Textures
        pos_x: -600
        pos_y: 0

      # Fresnel for edge glow
      - id: FresnelEffect
        type: Fresnel
        pos_x: -400
        pos_y: 100

      # Color tint
      - id: ShieldColor
        type: VectorParam
        properties:
          parameter_name: ShieldColor
          default_value: [0.2, 0.5, 1.0, 1.0]
        pos_x: -400
        pos_y: -100

      # Intensity control
      - id: Intensity
        type: ScalarParam
        properties:
          parameter_name: Intensity
          default_value: 2.0
        pos_x: -400
        pos_y: 200

      # Multiply pattern with color
      - id: ColoredPattern
        type: Multiply
        pos_x: -200
        pos_y: 0

      # Add fresnel glow
      - id: FinalEmissive
        type: Add
        pos_x: 0
        pos_y: 0

      # Opacity from pattern alpha
      - id: PatternOpacity
        type: Multiply
        pos_x: -200
        pos_y: 200

    connections:
      - from: [EnergyPattern, RGB]
        to: [ColoredPattern, A]
      - from: [ShieldColor, ""]
        to: [ColoredPattern, B]
      - from: [ColoredPattern, ""]
        to: [FinalEmissive, A]
      - from: [FresnelEffect, ""]
        to: [FinalEmissive, B]
      - from: [FinalEmissive, ""]
        to: [Material, EmissiveColor]
      - from: [EnergyPattern, A]
        to: [PatternOpacity, A]
      - from: [Intensity, ""]
        to: [PatternOpacity, B]
      - from: [PatternOpacity, ""]
        to: [Material, Opacity]

  - name: M_FatherDecalMark
    folder: Materials/Father/Decals
    blend_mode: Translucent
    shading_model: Unlit
    material_domain: DeferredDecal  # v4.0 decal material
    decal_response: ColorNormalRoughness
    expressions:
      - id: MarkTexture
        type: TextureSampleParameter2D
        texture_path: /Game/Textures/T_TargetMark
        sampler_type: Color
        properties:
          parameter_name: MarkTexture
        pos_x: -300
        pos_y: 0
    connections:
      - from: [MarkTexture, RGB]
        to: [Material, BaseColor]
      - from: [MarkTexture, A]
        to: [Material, Opacity]
```

---

## Testing Checklist

### Phase 1 Tests

**MF_ Connection Wiring:**
- [ ] Create material function with 2 inputs, 1 output, 3 expressions, 4 connections
- [ ] Verify connections are wired in editor (no manual setup needed)
- [ ] Test expression types: FunctionInput, Multiply, Add, FunctionOutput
- [ ] Verify metadata fields appear in function properties

**BB_ Enhancements:**
- [ ] Create blackboard with parent reference
- [ ] Verify inherited keys appear in child blackboard
- [ ] Create Object key with custom base_class (ANarrativeCharacter)
- [ ] Verify base class restriction in editor key properties
- [ ] Verify description and category appear in editor

**FC_ Enhancements:**
- [ ] Create curve with pre/post extrapolation modes
- [ ] Verify curve loops correctly with Cycle mode
- [ ] Create curve with User tangent mode and custom tangents
- [ ] Verify tangent handles in curve editor

### Phase 2 Tests

**BT_ Enhancements:**
- [ ] Create behavior tree with nested composite nodes
- [ ] Verify child wiring (parent-child relationships)
- [ ] Add task with properties, verify via reflection
- [ ] Add decorator with flow_abort_mode, verify in editor
- [ ] Add service with random_deviation, verify in editor
- [ ] Test blackboard key selector population

### Phase 3 Tests

**M_ Enhancements:**
- [ ] Create material with material_domain: PostProcess
- [ ] Create material with TextureSampleParameter2D
- [ ] Verify texture loads and displays in material editor
- [ ] Test translucency settings (pass, separate, responsive)
- [ ] Verify lighting flags (cast shadow, block GI)
- [ ] Test Nanite properties (UE5.7+)

---

## Version Information

**Plugin Version:** v4.0
**Target Automation Levels:**
- BB_: 98%  100%
- BT_: 80%  95%
- M_: 85%  95%
- MF_: 85%  98%
- FC_: 98%  100%

**Estimated Implementation Time:** 31 hours total
- Phase 1: 9 hours
- Phase 2: 10 hours
- Phase 3: 12 hours

---

## Notes for Implementation

1. **Build after each phase** - Run `cycle` action to verify no compile errors
2. **Delete asset folder between tests** - Asset Registry caching may hide changes
3. **Check log output** - Generator logs will indicate property setting success/failure
4. **Reflection warnings are acceptable** - Some UE5 properties may have different names
5. **ComputeHash updates are critical** - All new fields must be included for regen safety
