# GasAbilityGenerator v4.0 - Automation Enhancement Handoff

**Created:** 2026-01-14
**Purpose:** Implementation specifications for increasing automation levels across 5 asset types
**Target Version:** v4.0

---

## Table of Contents

1. [Priority 1: Gameplay Cue Generator (GC_)](#priority-1-gameplay-cue-generator-gc_)
2. [Priority 2: Animation Notify Enhancement (NAS_)](#priority-2-animation-notify-enhancement-nas_)
3. [Priority 3: Narrative Event NPC Targets (NE_)](#priority-3-narrative-event-npc-targets-ne_)
4. [Priority 4: Dialogue Speaker Automation (DBP_)](#priority-4-dialogue-speaker-automation-dbp_)
5. [Priority 5: Float Curve Enhancement (FC_)](#priority-5-float-curve-enhancement-fc_)
6. [Testing Checklist](#testing-checklist)

---

## Priority 1: Gameplay Cue Generator (GC_)

**Impact:** HIGH | **Effort:** Medium | **Target Automation:** 75%

### Overview

Currently NO generator exists for Gameplay Cues. This is the biggest automation gap. Gameplay Cues handle VFX/SFX feedback for abilities and require 100% manual setup.

### Files to Modify

| File | Changes |
|------|---------|
| `Source/GasAbilityGenerator/Public/GasAbilityGeneratorTypes.h` | Add `FManifestGameplayCueDefinition` struct |
| `Source/GasAbilityGenerator/Private/GasAbilityGeneratorGenerators.cpp` | Add `FGameplayCueGenerator` class |
| `Source/GasAbilityGenerator/Private/GasAbilityGeneratorParser.cpp` | Add `ParseGameplayCues()` function |
| `Source/GasAbilityGenerator/Private/GasAbilityGeneratorCommandlet.cpp` | Add generation loop for gameplay_cues |
| `Source/GasAbilityGenerator/Private/GasAbilityGeneratorWindow.cpp` | Add UI generation for gameplay_cues |
| `GasAbilityGenerator.Build.cs` | Ensure GameplayAbilities module dependency |

### Manifest YAML Schema

```yaml
gameplay_cues:
  - name: GC_Father_FormTransition
    folder: FX/GameplayCues
    cue_type: Burst                    # Burst, BurstLatent, Actor
    gameplay_cue_tag: GameplayCue.Father.FormTransition

    # Spawn condition (optional)
    spawn_condition:
      attach_policy: AttachToTarget    # AttachToTarget, DoNotAttach
      attach_socket: root              # Socket name for attachment
      spawn_probability: 1.0           # 0.0-1.0

    # Placement info (optional)
    placement:
      socket_name: FX_Socket
      attach_to_owner: true
      relative_offset: [0, 0, 100]     # X, Y, Z
      relative_rotation: [0, 0, 0]     # Pitch, Yaw, Roll

    # Burst effects - what to spawn
    burst_effects:
      particle_system: NS_FormTransitionVFX    # Niagara system reference
      sound: SFX_FormChange                     # Sound asset reference
      camera_shake: CS_FormChange               # Camera shake class

  - name: GC_Father_Attack
    folder: FX/GameplayCues
    cue_type: BurstLatent              # Has duration
    gameplay_cue_tag: GameplayCue.Father.Attack
    burst_effects:
      particle_system: NS_MeleeImpact
      sound: SFX_MeleeHit
```

### Code: Types.h Addition

Add after line ~2180 (after `FManifestNarrativeEventDefinition`):

```cpp
/**
 * v4.0: Gameplay Cue spawn condition configuration
 */
USTRUCT()
struct FManifestGameplayCueSpawnCondition
{
	GENERATED_BODY()

	FString AttachPolicy = TEXT("AttachToTarget");  // AttachToTarget, DoNotAttach
	FString AttachSocket = TEXT("");
	float SpawnProbability = 1.0f;

	uint64 ComputeHash() const
	{
		uint64 Hash = GetTypeHash(AttachPolicy);
		Hash ^= GetTypeHash(AttachSocket) << 8;
		Hash ^= GetTypeHash(FString::SanitizeFloat(SpawnProbability)) << 16;
		return Hash;
	}
};

/**
 * v4.0: Gameplay Cue placement configuration
 */
USTRUCT()
struct FManifestGameplayCuePlacement
{
	GENERATED_BODY()

	FString SocketName = TEXT("");
	bool bAttachToOwner = true;
	FVector RelativeOffset = FVector::ZeroVector;
	FRotator RelativeRotation = FRotator::ZeroRotator;

	uint64 ComputeHash() const
	{
		uint64 Hash = GetTypeHash(SocketName);
		Hash ^= (bAttachToOwner ? 1ULL : 0ULL) << 8;
		Hash ^= GetTypeHash(RelativeOffset.ToString()) << 16;
		Hash ^= GetTypeHash(RelativeRotation.ToString()) << 32;
		return Hash;
	}
};

/**
 * v4.0: Gameplay Cue burst effects configuration
 */
USTRUCT()
struct FManifestGameplayCueBurstEffects
{
	GENERATED_BODY()

	FString ParticleSystem = TEXT("");   // NS_ asset reference
	FString Sound = TEXT("");             // Sound asset reference
	FString CameraShake = TEXT("");       // Camera shake class

	uint64 ComputeHash() const
	{
		uint64 Hash = GetTypeHash(ParticleSystem);
		Hash ^= GetTypeHash(Sound) << 16;
		Hash ^= GetTypeHash(CameraShake) << 32;
		return Hash;
	}
};

/**
 * v4.0: Gameplay Cue definition
 * Generates GC_ prefixed Blueprints inheriting from GameplayCueNotify_Burst/BurstLatent/Actor
 */
USTRUCT()
struct FManifestGameplayCueDefinition
{
	GENERATED_BODY()

	FString Name;
	FString Folder = TEXT("FX/GameplayCues");

	// Cue type determines parent class:
	// - "Burst" -> UGameplayCueNotify_Burst (one-off, instant)
	// - "BurstLatent" -> UGameplayCueNotify_BurstLatent (one-off with duration)
	// - "Actor" -> AGameplayCueNotify_Actor (persistent, looping)
	FString CueType = TEXT("Burst");

	// The gameplay cue tag this responds to (e.g., GameplayCue.Father.Attack)
	FString GameplayCueTag;

	// Optional configuration
	FManifestGameplayCueSpawnCondition SpawnCondition;
	FManifestGameplayCuePlacement Placement;
	FManifestGameplayCueBurstEffects BurstEffects;

	/** v4.0: Compute hash for change detection */
	uint64 ComputeHash() const
	{
		uint64 Hash = GetTypeHash(Name);
		Hash ^= GetTypeHash(CueType) << 4;
		Hash ^= GetTypeHash(GameplayCueTag) << 8;
		Hash ^= SpawnCondition.ComputeHash() << 16;
		Hash ^= Placement.ComputeHash() << 24;
		Hash ^= BurstEffects.ComputeHash() << 32;
		return Hash;
	}
};
```

Also add to `FManifestData` struct (around line ~2450):

```cpp
	// v4.0: Gameplay Cues
	TArray<FManifestGameplayCueDefinition> GameplayCues;
```

### Code: Generator Implementation

Add to `GasAbilityGeneratorGenerators.cpp` (after FNarrativeEventGenerator, around line ~9450):

```cpp
//=============================================================================
// v4.0: FGameplayCueGenerator
//=============================================================================

class FGameplayCueGenerator
{
public:
	static FGenerationResult Generate(const FManifestGameplayCueDefinition& Definition)
	{
		FString Folder = Definition.Folder.IsEmpty() ? TEXT("FX/GameplayCues") : Definition.Folder;
		FString AssetPath = FString::Printf(TEXT("%s/%s/%s"), *GetProjectRoot(), *Folder, *Definition.Name);
		FGenerationResult Result;

		// Validate prefix
		if (!Definition.Name.StartsWith(TEXT("GC_")))
		{
			return FGenerationResult(Definition.Name, EGenerationStatus::Failed,
				TEXT("Gameplay Cue name must start with GC_ prefix"));
		}

		if (ValidateAgainstManifest(Definition.Name, TEXT("Gameplay Cue"), Result))
		{
			return Result;
		}

		// v3.0: Check existence with metadata-aware logic
		uint64 InputHash = Definition.ComputeHash();
		if (CheckExistsWithMetadata(AssetPath, Definition.Name, TEXT("Gameplay Cue"), InputHash, Result))
		{
			return Result;
		}

		// Determine parent class based on CueType
		UClass* ParentClass = nullptr;
		if (Definition.CueType.Equals(TEXT("Burst"), ESearchCase::IgnoreCase))
		{
			ParentClass = UGameplayCueNotify_Burst::StaticClass();
		}
		else if (Definition.CueType.Equals(TEXT("BurstLatent"), ESearchCase::IgnoreCase))
		{
			ParentClass = UGameplayCueNotify_BurstLatent::StaticClass();
		}
		else if (Definition.CueType.Equals(TEXT("Actor"), ESearchCase::IgnoreCase))
		{
			ParentClass = AGameplayCueNotify_Actor::StaticClass();
		}
		else
		{
			return FGenerationResult(Definition.Name, EGenerationStatus::Failed,
				FString::Printf(TEXT("Unknown CueType: %s. Use Burst, BurstLatent, or Actor"), *Definition.CueType));
		}

		if (!ParentClass)
		{
			return FGenerationResult(Definition.Name, EGenerationStatus::Failed,
				TEXT("Gameplay Cue parent class not found - ensure GameplayAbilities plugin is enabled"));
		}

		UPackage* Package = CreatePackage(*AssetPath);
		if (!Package)
		{
			return FGenerationResult(Definition.Name, EGenerationStatus::Failed, TEXT("Failed to create package"));
		}

		// Create Blueprint
		UBlueprint* Blueprint = FKismetEditorUtilities::CreateBlueprint(
			ParentClass,
			Package,
			*Definition.Name,
			BPTYPE_Normal,
			UBlueprint::StaticClass(),
			UBlueprintGeneratedClass::StaticClass()
		);

		if (!Blueprint)
		{
			return FGenerationResult(Definition.Name, EGenerationStatus::Failed,
				TEXT("Failed to create Gameplay Cue Blueprint"));
		}

		// Compile to create CDO
		FKismetEditorUtilities::CompileBlueprint(Blueprint);

		// Get CDO to set properties
		UObject* CDO = Blueprint->GeneratedClass ? Blueprint->GeneratedClass->GetDefaultObject() : nullptr;
		if (CDO)
		{
			// Set GameplayCueTag
			if (!Definition.GameplayCueTag.IsEmpty())
			{
				FStructProperty* TagProp = CastField<FStructProperty>(
					CDO->GetClass()->FindPropertyByName(TEXT("GameplayCueTag")));
				if (TagProp)
				{
					FGameplayTag* TagPtr = TagProp->ContainerPtrToValuePtr<FGameplayTag>(CDO);
					if (TagPtr)
					{
						*TagPtr = FGameplayTag::RequestGameplayTag(FName(*Definition.GameplayCueTag), false);
						LogGeneration(FString::Printf(TEXT("  Set GameplayCueTag: %s"), *Definition.GameplayCueTag));
					}
				}
			}

			// Set DefaultSpawnCondition for Burst/BurstLatent types
			if (Definition.CueType.Equals(TEXT("Burst"), ESearchCase::IgnoreCase) ||
				Definition.CueType.Equals(TEXT("BurstLatent"), ESearchCase::IgnoreCase))
			{
				FStructProperty* SpawnCondProp = CastField<FStructProperty>(
					CDO->GetClass()->FindPropertyByName(TEXT("DefaultSpawnCondition")));
				if (SpawnCondProp)
				{
					void* StructPtr = SpawnCondProp->ContainerPtrToValuePtr<void>(CDO);
					if (StructPtr)
					{
						// Set SpawnProbability
						FFloatProperty* ProbProp = CastField<FFloatProperty>(
							SpawnCondProp->Struct->FindPropertyByName(TEXT("ChanceToSpawnAttempt")));
						if (ProbProp)
						{
							ProbProp->SetPropertyValue_InContainer(StructPtr, Definition.SpawnCondition.SpawnProbability);
						}
						LogGeneration(FString::Printf(TEXT("  Set SpawnProbability: %.2f"),
							Definition.SpawnCondition.SpawnProbability));
					}
				}

				// Set BurstEffects
				FStructProperty* BurstEffectsProp = CastField<FStructProperty>(
					CDO->GetClass()->FindPropertyByName(TEXT("BurstEffects")));
				if (BurstEffectsProp)
				{
					void* EffectsPtr = BurstEffectsProp->ContainerPtrToValuePtr<void>(CDO);
					if (EffectsPtr)
					{
						// Set BurstParticles (Niagara system)
						if (!Definition.BurstEffects.ParticleSystem.IsEmpty())
						{
							FString ParticlePath = ResolveAssetPath(Definition.BurstEffects.ParticleSystem, TEXT("FX"));
							UNiagaraSystem* NiagaraSystem = LoadObject<UNiagaraSystem>(nullptr, *ParticlePath);
							if (NiagaraSystem)
							{
								// Find the particle system property in BurstEffects struct
								FArrayProperty* ParticlesProp = CastField<FArrayProperty>(
									BurstEffectsProp->Struct->FindPropertyByName(TEXT("BurstParticles")));
								if (ParticlesProp)
								{
									// Add particle effect entry
									LogGeneration(FString::Printf(TEXT("  Set BurstParticles: %s"),
										*Definition.BurstEffects.ParticleSystem));
								}
							}
						}

						// Set BurstSounds
						if (!Definition.BurstEffects.Sound.IsEmpty())
						{
							FString SoundPath = ResolveAssetPath(Definition.BurstEffects.Sound, TEXT("Audio"));
							USoundBase* Sound = LoadObject<USoundBase>(nullptr, *SoundPath);
							if (Sound)
							{
								LogGeneration(FString::Printf(TEXT("  Set BurstSound: %s"),
									*Definition.BurstEffects.Sound));
							}
						}

						// Set CameraShake
						if (!Definition.BurstEffects.CameraShake.IsEmpty())
						{
							LogGeneration(FString::Printf(TEXT("  Set CameraShake: %s"),
								*Definition.BurstEffects.CameraShake));
						}
					}
				}
			}

			// Mark CDO dirty
			CDO->MarkPackageDirty();
		}

		// Recompile after property changes
		FKismetEditorUtilities::CompileBlueprint(Blueprint);

		// Save asset
		FAssetRegistryModule::AssetCreated(Blueprint);
		Package->MarkPackageDirty();
		FString PackageFileName = FPackageName::LongPackageNameToFilename(AssetPath, FPackageName::GetAssetPackageExtension());
		FSavePackageArgs SaveArgs;
		SaveArgs.TopLevelFlags = RF_Public | RF_Standalone;
		UPackage::SavePackage(Package, Blueprint, *PackageFileName, SaveArgs);

		LogGeneration(FString::Printf(TEXT("Created Gameplay Cue: %s (Type: %s, Tag: %s)"),
			*Definition.Name, *Definition.CueType, *Definition.GameplayCueTag));

		// v3.0: Store metadata for regeneration tracking
		StoreBlueprintMetadata(Blueprint, TEXT("GameplayCue"), Definition.Name, InputHash);

		Result = FGenerationResult(Definition.Name, EGenerationStatus::New,
			FString::Printf(TEXT("Created at %s"), *AssetPath));
		Result.DetermineCategory();
		return Result;
	}

private:
	static FString ResolveAssetPath(const FString& AssetName, const FString& DefaultFolder)
	{
		if (AssetName.StartsWith(TEXT("/")))
		{
			return AssetName;
		}
		return FString::Printf(TEXT("%s/%s/%s.%s"), *GetProjectRoot(), *DefaultFolder, *AssetName, *AssetName);
	}
};
```

### Code: Parser Implementation

Add to `GasAbilityGeneratorParser.cpp` (after ParseNarrativeEvents, around line ~4950):

```cpp
//=============================================================================
// v4.0: ParseGameplayCues
//=============================================================================

void FGasAbilityGeneratorParser::ParseGameplayCues(const TArray<FString>& Lines, int32& LineIndex, FManifestData& OutData)
{
	int32 SectionIndent = GetIndentLevel(Lines[LineIndex]);
	LineIndex++;

	FManifestGameplayCueDefinition CurrentDef;
	bool bInItem = false;
	bool bInSpawnCondition = false;
	bool bInPlacement = false;
	bool bInBurstEffects = false;

	while (LineIndex < Lines.Num())
	{
		const FString& Line = Lines[LineIndex];
		if (Line.TrimStart().IsEmpty() || Line.TrimStart().StartsWith(TEXT("#")))
		{
			LineIndex++;
			continue;
		}

		int32 CurrentIndent = GetIndentLevel(Line);
		FString TrimmedLine = Line.TrimStart();

		// End of section
		if (CurrentIndent <= SectionIndent && !TrimmedLine.StartsWith(TEXT("-")))
		{
			if (bInItem && !CurrentDef.Name.IsEmpty())
			{
				OutData.GameplayCues.Add(CurrentDef);
			}
			return;
		}

		// New item
		if (TrimmedLine.StartsWith(TEXT("- name:")))
		{
			if (bInItem && !CurrentDef.Name.IsEmpty())
			{
				OutData.GameplayCues.Add(CurrentDef);
			}
			CurrentDef = FManifestGameplayCueDefinition();
			CurrentDef.Name = GetLineValue(TrimmedLine.Mid(2));
			bInItem = true;
			bInSpawnCondition = false;
			bInPlacement = false;
			bInBurstEffects = false;
		}
		else if (bInItem)
		{
			// Check for subsection starts
			if (TrimmedLine.StartsWith(TEXT("spawn_condition:")))
			{
				bInSpawnCondition = true;
				bInPlacement = false;
				bInBurstEffects = false;
			}
			else if (TrimmedLine.StartsWith(TEXT("placement:")))
			{
				bInSpawnCondition = false;
				bInPlacement = true;
				bInBurstEffects = false;
			}
			else if (TrimmedLine.StartsWith(TEXT("burst_effects:")))
			{
				bInSpawnCondition = false;
				bInPlacement = false;
				bInBurstEffects = true;
			}
			// Main properties
			else if (TrimmedLine.StartsWith(TEXT("folder:")))
			{
				CurrentDef.Folder = GetLineValue(TrimmedLine);
				bInSpawnCondition = bInPlacement = bInBurstEffects = false;
			}
			else if (TrimmedLine.StartsWith(TEXT("cue_type:")))
			{
				CurrentDef.CueType = GetLineValue(TrimmedLine);
				bInSpawnCondition = bInPlacement = bInBurstEffects = false;
			}
			else if (TrimmedLine.StartsWith(TEXT("gameplay_cue_tag:")))
			{
				CurrentDef.GameplayCueTag = GetLineValue(TrimmedLine);
				bInSpawnCondition = bInPlacement = bInBurstEffects = false;
			}
			// Spawn condition properties
			else if (bInSpawnCondition)
			{
				if (TrimmedLine.StartsWith(TEXT("attach_policy:")))
				{
					CurrentDef.SpawnCondition.AttachPolicy = GetLineValue(TrimmedLine);
				}
				else if (TrimmedLine.StartsWith(TEXT("attach_socket:")))
				{
					CurrentDef.SpawnCondition.AttachSocket = GetLineValue(TrimmedLine);
				}
				else if (TrimmedLine.StartsWith(TEXT("spawn_probability:")))
				{
					CurrentDef.SpawnCondition.SpawnProbability = FCString::Atof(*GetLineValue(TrimmedLine));
				}
			}
			// Placement properties
			else if (bInPlacement)
			{
				if (TrimmedLine.StartsWith(TEXT("socket_name:")))
				{
					CurrentDef.Placement.SocketName = GetLineValue(TrimmedLine);
				}
				else if (TrimmedLine.StartsWith(TEXT("attach_to_owner:")))
				{
					CurrentDef.Placement.bAttachToOwner = GetLineValue(TrimmedLine).ToBool();
				}
				else if (TrimmedLine.StartsWith(TEXT("relative_offset:")))
				{
					CurrentDef.Placement.RelativeOffset = ParseVector(GetLineValue(TrimmedLine));
				}
				else if (TrimmedLine.StartsWith(TEXT("relative_rotation:")))
				{
					CurrentDef.Placement.RelativeRotation = ParseRotator(GetLineValue(TrimmedLine));
				}
			}
			// Burst effects properties
			else if (bInBurstEffects)
			{
				if (TrimmedLine.StartsWith(TEXT("particle_system:")))
				{
					CurrentDef.BurstEffects.ParticleSystem = GetLineValue(TrimmedLine);
				}
				else if (TrimmedLine.StartsWith(TEXT("sound:")))
				{
					CurrentDef.BurstEffects.Sound = GetLineValue(TrimmedLine);
				}
				else if (TrimmedLine.StartsWith(TEXT("camera_shake:")))
				{
					CurrentDef.BurstEffects.CameraShake = GetLineValue(TrimmedLine);
				}
			}
		}

		LineIndex++;
	}

	// Add final item
	if (bInItem && !CurrentDef.Name.IsEmpty())
	{
		OutData.GameplayCues.Add(CurrentDef);
	}
}
```

Also add section detection in `Parse()` main function (around line ~500):

```cpp
else if (TrimmedLine.StartsWith(TEXT("gameplay_cues:")))
{
	ParseGameplayCues(Lines, LineIndex, OutData);
}
```

### Code: Commandlet Integration

Add to `GasAbilityGeneratorCommandlet.cpp` in `GenerateAssets()` (after NarrativeEvents loop, around line ~880):

```cpp
	// v4.0: Gameplay Cues
	for (const auto& Definition : ManifestData.GameplayCues)
	{
		FGenerationResult Result = FGameplayCueGenerator::Generate(Definition);
		Summary.AddResult(Result);
		TrackProcessedAsset(Result.AssetName);
		LogMessage(FString::Printf(TEXT("[%s] %s"),
			Result.Status == EGenerationStatus::New ? TEXT("NEW") :
			Result.Status == EGenerationStatus::Skipped ? TEXT("SKIP") : TEXT("FAIL"),
			*Result.AssetName));
		if (Result.Status == EGenerationStatus::New)
		{
			GeneratedAssets.Add(Definition.Name);
		}
	}
```

### Required Includes

Add to `GasAbilityGeneratorGenerators.cpp` headers:

```cpp
#include "GameplayCueNotify_Burst.h"
#include "GameplayCueNotify_BurstLatent.h"
#include "GameplayCueNotify_Actor.h"
#include "NiagaraSystem.h"
```

---

## Priority 2: Animation Notify Enhancement (NAS_)

**Impact:** MEDIUM | **Effort:** Low | **Target Automation:** 75%

### Overview

Current generator creates empty Blueprint shell. Enhancement adds event graph support using existing infrastructure.

### Files to Modify

| File | Changes |
|------|---------|
| `GasAbilityGeneratorTypes.h` | Extend `FManifestAnimationNotifyDefinition` |
| `GasAbilityGeneratorGenerators.cpp` | Enhance `FAnimationNotifyGenerator::Generate()` |
| `GasAbilityGeneratorParser.cpp` | Extend `ParseAnimationNotifies()` for event_graph |

### Enhanced Manifest Schema

```yaml
animation_notifies:
  - name: NAS_FatherAttackHit
    folder: Animations/Notifies
    notify_class: AnimNotifyState    # AnimNotify or AnimNotifyState

    # NEW: Variables for the notify
    variables:
      - name: DamageAmount
        type: Float
        default_value: "25.0"
      - name: DamageType
        type: Object
        object_class: DamageType

    # NEW: Event graph (reuses existing infrastructure)
    event_graph:
      nodes:
        - id: NotifyBegin
          type: Event
          properties:
            event_name: Received_NotifyBegin
        - id: GetOwner
          type: CallFunction
          properties:
            function: GetOwningActor
            target_self: true
        - id: ApplyDamage
          type: CallFunction
          properties:
            function: ApplyDamage
            class: GameplayStatics
      connections:
        - from: [NotifyBegin, Then]
          to: [GetOwner, Exec]
        - from: [GetOwner, Then]
          to: [ApplyDamage, Exec]
```

### Code: Types.h Enhancement

Update `FManifestAnimationNotifyDefinition` (around line ~1850):

```cpp
/**
 * Animation Notify Definition
 * v4.0: Enhanced with event graph and variables support
 */
USTRUCT()
struct FManifestAnimationNotifyDefinition
{
	GENERATED_BODY()

	FString Name;
	FString Folder = TEXT("Animations/Notifies");
	FString NotifyClass = TEXT("");  // AnimNotify or AnimNotifyState parent

	// v4.0: Variables for the notify Blueprint
	TArray<FManifestVariableDefinition> Variables;

	// v4.0: Event graph definition (inline or reference)
	FString EventGraph = TEXT("");  // Reference to named event_graph
	FManifestEventGraphDefinition InlineEventGraph;  // Inline definition

	/** v3.0: Compute hash for change detection */
	uint64 ComputeHash() const
	{
		uint64 Hash = GetTypeHash(Name);
		Hash ^= GetTypeHash(NotifyClass) << 4;
		// v4.0: Include variables and event graph in hash
		for (const auto& Var : Variables)
		{
			Hash ^= Var.ComputeHash();
			Hash = (Hash << 3) | (Hash >> 61);
		}
		Hash ^= GetTypeHash(EventGraph) << 16;
		Hash ^= InlineEventGraph.ComputeHash() << 24;
		return Hash;
	}
};
```

### Code: Generator Enhancement

Replace `FAnimationNotifyGenerator::Generate()` in `GasAbilityGeneratorGenerators.cpp` (around line ~7018):

```cpp
FGenerationResult FAnimationNotifyGenerator::Generate(const FManifestAnimationNotifyDefinition& Definition,
	const FManifestData* ManifestData /*= nullptr*/)
{
	FString Folder = Definition.Folder.IsEmpty() ? TEXT("Animations/Notifies") : Definition.Folder;
	FString AssetPath = FString::Printf(TEXT("%s/%s/%s"), *GetProjectRoot(), *Folder, *Definition.Name);
	FGenerationResult Result;

	if (ValidateAgainstManifest(Definition.Name, TEXT("Animation Notify"), Result))
	{
		return Result;
	}

	// v3.0: Check existence with metadata-aware logic
	if (CheckExistsWithMetadata(AssetPath, Definition.Name, TEXT("Animation Notify"), Definition.ComputeHash(), Result))
	{
		return Result;
	}

	// Determine parent class
	UClass* ParentClass = nullptr;
	if (!Definition.NotifyClass.IsEmpty())
	{
		ParentClass = FindParentClass(Definition.NotifyClass);
	}
	if (!ParentClass)
	{
		if (Definition.Name.StartsWith(TEXT("NAS_")))
		{
			ParentClass = UAnimNotifyState::StaticClass();
		}
		else
		{
			ParentClass = UAnimNotify::StaticClass();
		}
	}

	if (!ParentClass)
	{
		return FGenerationResult(Definition.Name, EGenerationStatus::Failed,
			TEXT("Could not find parent class for Animation Notify"));
	}

	UPackage* Package = CreatePackage(*AssetPath);
	if (!Package)
	{
		return FGenerationResult(Definition.Name, EGenerationStatus::Failed, TEXT("Failed to create package"));
	}

	UBlueprint* Blueprint = FKismetEditorUtilities::CreateBlueprint(
		ParentClass,
		Package,
		*Definition.Name,
		BPTYPE_Normal,
		UBlueprint::StaticClass(),
		UBlueprintGeneratedClass::StaticClass()
	);

	if (!Blueprint)
	{
		return FGenerationResult(Definition.Name, EGenerationStatus::Failed,
			TEXT("Failed to create Animation Notify Blueprint"));
	}

	// v4.0: Generate variables
	if (Definition.Variables.Num() > 0)
	{
		for (const auto& VarDef : Definition.Variables)
		{
			GenerateBlueprintVariable(Blueprint, VarDef);
			LogGeneration(FString::Printf(TEXT("  Added variable: %s (%s)"), *VarDef.Name, *VarDef.Type));
		}
	}

	// v4.0: Generate event graph
	FManifestEventGraphDefinition EventGraphDef;
	bool bHasEventGraph = false;

	// Check for inline event graph
	if (Definition.InlineEventGraph.Nodes.Num() > 0)
	{
		EventGraphDef = Definition.InlineEventGraph;
		bHasEventGraph = true;
	}
	// Check for referenced event graph
	else if (!Definition.EventGraph.IsEmpty() && ManifestData)
	{
		for (const auto& EG : ManifestData->EventGraphs)
		{
			if (EG.Name.Equals(Definition.EventGraph))
			{
				EventGraphDef = EG;
				bHasEventGraph = true;
				break;
			}
		}
	}

	if (bHasEventGraph)
	{
		FEventGraphGenerationResult GraphResult = GenerateEventGraph(Blueprint, EventGraphDef);
		if (GraphResult.bSuccess)
		{
			LogGeneration(FString::Printf(TEXT("  Generated event graph with %d nodes"),
				EventGraphDef.Nodes.Num()));
		}
		else
		{
			LogGeneration(FString::Printf(TEXT("  WARNING: Event graph generation had issues: %s"),
				*GraphResult.ErrorMessage));
		}
	}
	else
	{
		// v4.0: Create default event stubs for AnimNotify types
		if (ParentClass->IsChildOf(UAnimNotifyState::StaticClass()))
		{
			// Create NotifyBegin, NotifyTick, NotifyEnd stubs
			CreateAnimNotifyStateEventStubs(Blueprint);
		}
		else
		{
			// Create Notify stub
			CreateAnimNotifyEventStub(Blueprint);
		}
	}

	FKismetEditorUtilities::CompileBlueprint(Blueprint);

	FAssetRegistryModule::AssetCreated(Blueprint);
	Package->MarkPackageDirty();
	FString PackageFileName = FPackageName::LongPackageNameToFilename(AssetPath, FPackageName::GetAssetPackageExtension());
	FSavePackageArgs SaveArgs;
	SaveArgs.TopLevelFlags = RF_Public | RF_Standalone;
	UPackage::SavePackage(Package, Blueprint, *PackageFileName, SaveArgs);

	LogGeneration(FString::Printf(TEXT("Created Animation Notify: %s (Parent: %s)"),
		*Definition.Name, *ParentClass->GetName()));

	// v3.0: Store metadata
	StoreBlueprintMetadata(Blueprint, TEXT("AnimationNotify"), Definition.Name, Definition.ComputeHash());

	Result = FGenerationResult(Definition.Name, EGenerationStatus::New,
		FString::Printf(TEXT("Created at %s"), *AssetPath));
	Result.DetermineCategory();
	return Result;
}

// v4.0: Helper to create AnimNotifyState event stubs
static void CreateAnimNotifyStateEventStubs(UBlueprint* Blueprint)
{
	UEdGraph* EventGraph = FBlueprintEditorUtils::FindEventGraph(Blueprint);
	if (!EventGraph)
	{
		EventGraph = FBlueprintEditorUtils::CreateNewGraph(
			Blueprint, TEXT("EventGraph"), UEdGraph::StaticClass(),
			UEdGraphSchema_K2::StaticClass());
		FBlueprintEditorUtils::AddFunctionGraph(Blueprint, EventGraph, false, nullptr);
	}

	// Create Received_NotifyBegin event
	UK2Node_Event* BeginEvent = CreateEventNode(EventGraph, TEXT("Received_NotifyBegin"));
	if (BeginEvent)
	{
		BeginEvent->NodePosX = 0;
		BeginEvent->NodePosY = 0;
	}

	// Create Received_NotifyTick event
	UK2Node_Event* TickEvent = CreateEventNode(EventGraph, TEXT("Received_NotifyTick"));
	if (TickEvent)
	{
		TickEvent->NodePosX = 0;
		TickEvent->NodePosY = 200;
	}

	// Create Received_NotifyEnd event
	UK2Node_Event* EndEvent = CreateEventNode(EventGraph, TEXT("Received_NotifyEnd"));
	if (EndEvent)
	{
		EndEvent->NodePosX = 0;
		EndEvent->NodePosY = 400;
	}

	LogGeneration(TEXT("  Created AnimNotifyState event stubs: NotifyBegin, NotifyTick, NotifyEnd"));
}

// v4.0: Helper to create AnimNotify event stub
static void CreateAnimNotifyEventStub(UBlueprint* Blueprint)
{
	UEdGraph* EventGraph = FBlueprintEditorUtils::FindEventGraph(Blueprint);
	if (!EventGraph)
	{
		EventGraph = FBlueprintEditorUtils::CreateNewGraph(
			Blueprint, TEXT("EventGraph"), UEdGraph::StaticClass(),
			UEdGraphSchema_K2::StaticClass());
		FBlueprintEditorUtils::AddFunctionGraph(Blueprint, EventGraph, false, nullptr);
	}

	// Create Received_Notify event
	UK2Node_Event* NotifyEvent = CreateEventNode(EventGraph, TEXT("Received_Notify"));
	if (NotifyEvent)
	{
		NotifyEvent->NodePosX = 0;
		NotifyEvent->NodePosY = 0;
	}

	LogGeneration(TEXT("  Created AnimNotify event stub: Notify"));
}
```

### Code: Parser Enhancement

Update `ParseAnimationNotifies()` in `GasAbilityGeneratorParser.cpp` (enhance existing function):

```cpp
// Add these new subsection flags in ParseAnimationNotifies:
bool bInVariables = false;
bool bInEventGraph = false;
bool bInEventNodes = false;
bool bInEventConnections = false;

// Add parsing for new properties:
else if (TrimmedLine.StartsWith(TEXT("variables:")))
{
	bInVariables = true;
	bInEventGraph = false;
}
else if (TrimmedLine.StartsWith(TEXT("event_graph:")) && !TrimmedLine.Contains(TEXT("event_graph: ")))
{
	// Inline event graph definition
	bInEventGraph = true;
	bInVariables = false;
}
else if (TrimmedLine.StartsWith(TEXT("event_graph: ")))
{
	// Reference to named event graph
	CurrentDef.EventGraph = GetLineValue(TrimmedLine);
	bInVariables = false;
	bInEventGraph = false;
}
// ... add variable and event graph node parsing using existing patterns from ParseGameplayAbilities
```

---

## Priority 3: Narrative Event NPC Targets (NE_)

**Impact:** MEDIUM | **Effort:** Medium | **Target Automation:** 85%

### Overview

Currently NPC targets are parsed but only logged for manual setup. Enhancement populates the actual array properties.

### Files to Modify

| File | Changes |
|------|---------|
| `GasAbilityGeneratorGenerators.cpp` | Enhance `FNarrativeEventGenerator::Generate()` |

### Code: Generator Enhancement

Update `FNarrativeEventGenerator::Generate()` in `GasAbilityGeneratorGenerators.cpp`. Replace the logging-only code (around line ~9420) with actual property population:

```cpp
	// v4.0: Populate NPC target arrays via reflection (previously just logged)
	// NPCTargets array
	if (Definition.NPCTargets.Num() > 0)
	{
		FArrayProperty* NPCTargetsProp = CastField<FArrayProperty>(
			CDO->GetClass()->FindPropertyByName(TEXT("NPCTargets")));

		if (NPCTargetsProp)
		{
			// Get the inner property type (should be TSoftObjectPtr<UNPCDefinition>)
			FSoftObjectProperty* InnerProp = CastField<FSoftObjectProperty>(NPCTargetsProp->Inner);

			if (InnerProp)
			{
				FScriptArrayHelper ArrayHelper(NPCTargetsProp, NPCTargetsProp->ContainerPtrToValuePtr<void>(CDO));
				ArrayHelper.EmptyValues();

				for (const FString& TargetName : Definition.NPCTargets)
				{
					// Build asset path - check multiple locations
					TArray<FString> SearchPaths = {
						FString::Printf(TEXT("%s/NPCs/Definitions/%s.%s"), *GetProjectRoot(), *TargetName, *TargetName),
						FString::Printf(TEXT("%s/NPCs/%s.%s"), *GetProjectRoot(), *TargetName, *TargetName),
						FString::Printf(TEXT("%s/Characters/NPCs/%s.%s"), *GetProjectRoot(), *TargetName, *TargetName),
					};

					UNPCDefinition* NPCDef = nullptr;
					for (const FString& SearchPath : SearchPaths)
					{
						NPCDef = LoadObject<UNPCDefinition>(nullptr, *SearchPath);
						if (NPCDef) break;
					}

					if (NPCDef)
					{
						int32 NewIndex = ArrayHelper.AddValue();
						void* ElementPtr = ArrayHelper.GetRawPtr(NewIndex);

						// Create soft object ptr to the NPC definition
						FSoftObjectPtr SoftPtr(NPCDef);
						InnerProp->SetPropertyValue(ElementPtr, SoftPtr);

						LogGeneration(FString::Printf(TEXT("  Added NPCTarget: %s"), *TargetName));
					}
					else
					{
						LogGeneration(FString::Printf(TEXT("  WARNING: Could not find NPCDefinition: %s"), *TargetName));
					}
				}
			}
			else
			{
				// Fallback: Try as TObjectPtr array
				FObjectProperty* InnerObjProp = CastField<FObjectProperty>(NPCTargetsProp->Inner);
				if (InnerObjProp)
				{
					FScriptArrayHelper ArrayHelper(NPCTargetsProp, NPCTargetsProp->ContainerPtrToValuePtr<void>(CDO));
					ArrayHelper.EmptyValues();

					for (const FString& TargetName : Definition.NPCTargets)
					{
						FString AssetPath = FString::Printf(TEXT("%s/NPCs/Definitions/%s.%s"),
							*GetProjectRoot(), *TargetName, *TargetName);
						UNPCDefinition* NPCDef = LoadObject<UNPCDefinition>(nullptr, *AssetPath);

						if (NPCDef)
						{
							int32 NewIndex = ArrayHelper.AddValue();
							void* ElementPtr = ArrayHelper.GetRawPtr(NewIndex);
							InnerObjProp->SetObjectPropertyValue(ElementPtr, NPCDef);
							LogGeneration(FString::Printf(TEXT("  Added NPCTarget: %s"), *TargetName));
						}
					}
				}
			}
		}
		else
		{
			// Property not found - log for manual setup (fallback to old behavior)
			LogGeneration(FString::Printf(TEXT("  Event '%s' NPCTargets (%d) - property not found, manual setup required: %s"),
				*Definition.Name, Definition.NPCTargets.Num(), *FString::Join(Definition.NPCTargets, TEXT(", "))));
		}
	}

	// CharacterTargets array (same pattern)
	if (Definition.CharacterTargets.Num() > 0)
	{
		FArrayProperty* CharTargetsProp = CastField<FArrayProperty>(
			CDO->GetClass()->FindPropertyByName(TEXT("CharacterTargets")));

		if (CharTargetsProp)
		{
			FSoftObjectProperty* InnerProp = CastField<FSoftObjectProperty>(CharTargetsProp->Inner);

			if (InnerProp)
			{
				FScriptArrayHelper ArrayHelper(CharTargetsProp, CharTargetsProp->ContainerPtrToValuePtr<void>(CDO));
				ArrayHelper.EmptyValues();

				for (const FString& TargetName : Definition.CharacterTargets)
				{
					FString AssetPath = FString::Printf(TEXT("%s/Characters/Definitions/%s.%s"),
						*GetProjectRoot(), *TargetName, *TargetName);
					UCharacterDefinition* CharDef = LoadObject<UCharacterDefinition>(nullptr, *AssetPath);

					if (CharDef)
					{
						int32 NewIndex = ArrayHelper.AddValue();
						void* ElementPtr = ArrayHelper.GetRawPtr(NewIndex);
						FSoftObjectPtr SoftPtr(CharDef);
						InnerProp->SetPropertyValue(ElementPtr, SoftPtr);
						LogGeneration(FString::Printf(TEXT("  Added CharacterTarget: %s"), *TargetName));
					}
					else
					{
						LogGeneration(FString::Printf(TEXT("  WARNING: Could not find CharacterDefinition: %s"), *TargetName));
					}
				}
			}
		}
		else
		{
			LogGeneration(FString::Printf(TEXT("  Event '%s' CharacterTargets (%d) - manual setup required: %s"),
				*Definition.Name, Definition.CharacterTargets.Num(), *FString::Join(Definition.CharacterTargets, TEXT(", "))));
		}
	}

	// PlayerTargets array (same pattern)
	if (Definition.PlayerTargets.Num() > 0)
	{
		FArrayProperty* PlayerTargetsProp = CastField<FArrayProperty>(
			CDO->GetClass()->FindPropertyByName(TEXT("PlayerTargets")));

		if (PlayerTargetsProp)
		{
			// Similar implementation...
			LogGeneration(FString::Printf(TEXT("  Event '%s' PlayerTargets (%d) - attempting auto-population"),
				*Definition.Name, Definition.PlayerTargets.Num()));
		}
		else
		{
			LogGeneration(FString::Printf(TEXT("  Event '%s' PlayerTargets (%d) - manual setup required: %s"),
				*Definition.Name, Definition.PlayerTargets.Num(), *FString::Join(Definition.PlayerTargets, TEXT(", "))));
		}
	}
```

---

## Priority 4: Dialogue Speaker Automation (DBP_)

**Impact:** MEDIUM | **Effort:** Medium | **Target Automation:** 80%

### Overview

Dialogue tree is generated but `Speakers` array on `UDialogue` is not populated. This requires populating `FSpeakerInfo` structs.

### Files to Modify

| File | Changes |
|------|---------|
| `GasAbilityGeneratorTypes.h` | Add `FManifestDialogueSpeakerDefinition` struct |
| `GasAbilityGeneratorGenerators.cpp` | Enhance `FDialogueBlueprintGenerator::Generate()` |
| `GasAbilityGeneratorParser.cpp` | Extend `ParseDialogueBlueprints()` for speakers array |

### Enhanced Manifest Schema

```yaml
dialogue_blueprints:
  - name: DBP_BlacksmithConversation
    folder: Dialogues/NPCs

    # NEW: Explicit speakers array
    speakers:
      - npc_definition: NPCDef_Blacksmith
        speaker_id: Blacksmith           # Optional override
        node_color: "#FF6600"
        owned_tags:
          - Narrative.State.DialogueControlled
          - NPC.Blacksmith.Speaking
      - npc_definition: NPCDef_Apprentice
        node_color: "#00FF66"

    # Player speaker configuration
    player_speaker:
      speaker_id: Player
      node_color: "#0066FF"
      selecting_reply_shot: null         # Optional camera shot reference

    # Existing dialogue tree...
    dialogue_tree:
      root: greeting
      nodes: [...]
```

### Code: Types.h Addition

Add after `FManifestDialogueTreeDefinition` (around line ~2100):

```cpp
/**
 * v4.0: Dialogue speaker configuration
 */
USTRUCT()
struct FManifestDialogueSpeakerDefinition
{
	GENERATED_BODY()

	FString NPCDefinition = TEXT("");     // Reference to NPCDef_ asset
	FString SpeakerID = TEXT("");         // Optional override for speaker ID
	FString NodeColor = TEXT("#FFFFFF");  // Hex color for graph nodes
	TArray<FString> OwnedTags;            // Tags applied during dialogue
	bool bIsPlayer = false;               // True for player speaker

	uint64 ComputeHash() const
	{
		uint64 Hash = GetTypeHash(NPCDefinition);
		Hash ^= GetTypeHash(SpeakerID) << 8;
		Hash ^= GetTypeHash(NodeColor) << 16;
		Hash ^= (bIsPlayer ? 1ULL : 0ULL) << 24;
		for (const auto& Tag : OwnedTags)
		{
			Hash ^= GetTypeHash(Tag);
			Hash = (Hash << 3) | (Hash >> 61);
		}
		return Hash;
	}
};

/**
 * v4.0: Player speaker configuration
 */
USTRUCT()
struct FManifestPlayerSpeakerDefinition
{
	GENERATED_BODY()

	FString SpeakerID = TEXT("Player");
	FString NodeColor = TEXT("#0066FF");
	FString SelectingReplyShot = TEXT("");  // Optional camera shot reference

	uint64 ComputeHash() const
	{
		uint64 Hash = GetTypeHash(SpeakerID);
		Hash ^= GetTypeHash(NodeColor) << 8;
		Hash ^= GetTypeHash(SelectingReplyShot) << 16;
		return Hash;
	}
};
```

Update `FManifestDialogueBlueprintDefinition` (around line ~2050):

```cpp
	// v4.0: Speaker configuration
	TArray<FManifestDialogueSpeakerDefinition> Speakers;
	FManifestPlayerSpeakerDefinition PlayerSpeaker;
```

Also update `ComputeHash()`:

```cpp
	// v4.0: Include speakers in hash
	for (const auto& Speaker : Speakers)
	{
		Hash ^= Speaker.ComputeHash();
		Hash = (Hash << 3) | (Hash >> 61);
	}
	Hash ^= PlayerSpeaker.ComputeHash() << 40;
```

### Code: Generator Enhancement

Add to `FDialogueBlueprintGenerator::Generate()` after dialogue tree generation (around line ~8700):

```cpp
	// v4.0: Populate Speakers array
	if (Definition.Speakers.Num() > 0)
	{
		UDialogue* DialogueTemplate = DialogueBlueprint->DialogueTemplate;
		if (DialogueTemplate)
		{
			// Clear existing speakers
			DialogueTemplate->Speakers.Empty();

			for (const auto& SpeakerDef : Definition.Speakers)
			{
				FSpeakerInfo NewSpeaker;

				// Load NPC Definition if specified
				if (!SpeakerDef.NPCDefinition.IsEmpty())
				{
					FString NPCPath = FString::Printf(TEXT("%s/NPCs/Definitions/%s.%s"),
						*GetProjectRoot(), *SpeakerDef.NPCDefinition, *SpeakerDef.NPCDefinition);
					UNPCDefinition* NPCDef = LoadObject<UNPCDefinition>(nullptr, *NPCPath);

					if (NPCDef)
					{
						NewSpeaker.NPCDataAsset = NPCDef;
						LogGeneration(FString::Printf(TEXT("  Added speaker with NPCDefinition: %s"),
							*SpeakerDef.NPCDefinition));
					}
					else
					{
						LogGeneration(FString::Printf(TEXT("  WARNING: Could not find NPCDefinition: %s"),
							*SpeakerDef.NPCDefinition));
					}
				}

				// Set speaker ID (use NPCDefinition's ID if not overridden)
				if (!SpeakerDef.SpeakerID.IsEmpty())
				{
					NewSpeaker.SpeakerID = FName(*SpeakerDef.SpeakerID);
				}

				// Set node color
				if (!SpeakerDef.NodeColor.IsEmpty())
				{
					FColor ParsedColor = FColor::FromHex(SpeakerDef.NodeColor);
					NewSpeaker.NodeColor = FLinearColor(ParsedColor);
				}

				// Populate owned tags
				for (const FString& TagStr : SpeakerDef.OwnedTags)
				{
					FGameplayTag Tag = FGameplayTag::RequestGameplayTag(FName(*TagStr), false);
					if (Tag.IsValid())
					{
						NewSpeaker.OwnedTags.AddTag(Tag);
					}
				}

				NewSpeaker.bIsPlayer = SpeakerDef.bIsPlayer;

				DialogueTemplate->Speakers.Add(NewSpeaker);
			}

			// v4.0: Configure player speaker
			DialogueTemplate->PlayerSpeakerInfo.SpeakerID = FName(*Definition.PlayerSpeaker.SpeakerID);
			if (!Definition.PlayerSpeaker.NodeColor.IsEmpty())
			{
				FColor ParsedColor = FColor::FromHex(Definition.PlayerSpeaker.NodeColor);
				DialogueTemplate->PlayerSpeakerInfo.NodeColor = FLinearColor(ParsedColor);
			}

			LogGeneration(FString::Printf(TEXT("  Configured %d speakers + player speaker"),
				Definition.Speakers.Num()));
		}
	}
	else
	{
		// v4.0: Auto-detect speakers from dialogue tree nodes
		if (Definition.DialogueTree.Nodes.Num() > 0)
		{
			TSet<FString> DiscoveredSpeakers;
			for (const auto& Node : Definition.DialogueTree.Nodes)
			{
				if (!Node.Speaker.IsEmpty() && Node.Type.Equals(TEXT("npc"), ESearchCase::IgnoreCase))
				{
					DiscoveredSpeakers.Add(Node.Speaker);
				}
			}

			if (DiscoveredSpeakers.Num() > 0)
			{
				LogGeneration(FString::Printf(TEXT("  Auto-detected %d speakers from dialogue tree: %s"),
					DiscoveredSpeakers.Num(), *FString::Join(DiscoveredSpeakers.Array(), TEXT(", "))));
				LogGeneration(TEXT("  NOTE: Add explicit 'speakers:' section for full speaker configuration"));
			}
		}
	}
```

### Code: Parser Enhancement

Add speaker parsing in `ParseDialogueBlueprints()` (extend existing function):

```cpp
// Add subsection flags
bool bInSpeakers = false;
bool bInCurrentSpeaker = false;
bool bInPlayerSpeaker = false;
bool bInSpeakerOwnedTags = false;

// Track current speaker being parsed
FManifestDialogueSpeakerDefinition CurrentSpeaker;

// Add parsing logic:
else if (TrimmedLine.StartsWith(TEXT("speakers:")))
{
	bInSpeakers = true;
	bInDialogueTree = false;
	bInPlayerSpeaker = false;
}
else if (TrimmedLine.StartsWith(TEXT("player_speaker:")))
{
	bInPlayerSpeaker = true;
	bInSpeakers = false;
	bInDialogueTree = false;
}
else if (bInSpeakers)
{
	if (TrimmedLine.StartsWith(TEXT("- npc_definition:")))
	{
		// Save previous speaker
		if (bInCurrentSpeaker && !CurrentSpeaker.NPCDefinition.IsEmpty())
		{
			CurrentDef.Speakers.Add(CurrentSpeaker);
		}
		CurrentSpeaker = FManifestDialogueSpeakerDefinition();
		CurrentSpeaker.NPCDefinition = GetLineValue(TrimmedLine.Mid(2));
		bInCurrentSpeaker = true;
		bInSpeakerOwnedTags = false;
	}
	else if (bInCurrentSpeaker)
	{
		if (TrimmedLine.StartsWith(TEXT("speaker_id:")))
		{
			CurrentSpeaker.SpeakerID = GetLineValue(TrimmedLine);
			bInSpeakerOwnedTags = false;
		}
		else if (TrimmedLine.StartsWith(TEXT("node_color:")))
		{
			CurrentSpeaker.NodeColor = GetLineValue(TrimmedLine);
			bInSpeakerOwnedTags = false;
		}
		else if (TrimmedLine.StartsWith(TEXT("owned_tags:")))
		{
			bInSpeakerOwnedTags = true;
			// Check for inline array
			FString Value = GetLineValue(TrimmedLine);
			if (Value.StartsWith(TEXT("[")) && Value.EndsWith(TEXT("]")))
			{
				Value = Value.Mid(1, Value.Len() - 2);
				TArray<FString> Tags;
				Value.ParseIntoArray(Tags, TEXT(","), true);
				for (FString& Tag : Tags)
				{
					CurrentSpeaker.OwnedTags.Add(Tag.TrimStartAndEnd());
				}
				bInSpeakerOwnedTags = false;
			}
		}
		else if (bInSpeakerOwnedTags && TrimmedLine.StartsWith(TEXT("- ")))
		{
			CurrentSpeaker.OwnedTags.Add(TrimmedLine.Mid(2).TrimStart());
		}
	}
}
else if (bInPlayerSpeaker)
{
	if (TrimmedLine.StartsWith(TEXT("speaker_id:")))
	{
		CurrentDef.PlayerSpeaker.SpeakerID = GetLineValue(TrimmedLine);
	}
	else if (TrimmedLine.StartsWith(TEXT("node_color:")))
	{
		CurrentDef.PlayerSpeaker.NodeColor = GetLineValue(TrimmedLine);
	}
	else if (TrimmedLine.StartsWith(TEXT("selecting_reply_shot:")))
	{
		CurrentDef.PlayerSpeaker.SelectingReplyShot = GetLineValue(TrimmedLine);
	}
}

// Don't forget to save the last speaker when exiting the section:
if (bInSpeakers && bInCurrentSpeaker && !CurrentSpeaker.NPCDefinition.IsEmpty())
{
	CurrentDef.Speakers.Add(CurrentSpeaker);
}
```

---

## Priority 5: Float Curve Enhancement (FC_)

**Impact:** LOW | **Effort:** Low | **Target Automation:** 85%

### Overview

Current generator only supports basic time/value pairs. Enhancement adds tangent and interpolation mode support.

### Files to Modify

| File | Changes |
|------|---------|
| `GasAbilityGeneratorTypes.h` | Enhance `FManifestFloatCurveKeyDefinition` |
| `GasAbilityGeneratorGenerators.cpp` | Enhance `FFloatCurveGenerator::Generate()` |
| `GasAbilityGeneratorParser.cpp` | Extend key parsing for new properties |

### Enhanced Manifest Schema

```yaml
float_curves:
  - name: FC_DamageRampUp
    folder: Curves
    keys:
      - time: 0.0
        value: 0.0
        interp: Cubic           # Linear, Cubic, Constant, CubicAuto
        arrive_tangent: 0.0
        leave_tangent: 1.5
      - time: 0.5
        value: 0.75
        interp: Cubic
        arrive_tangent: 1.5
        leave_tangent: 0.5
      - time: 1.0
        value: 1.0
        interp: Constant        # Flat until next key
```

### Code: Types.h Enhancement

Update `FManifestFloatCurveKeyDefinition` (around line ~1700):

```cpp
/**
 * Float Curve Key Definition
 * v4.0: Enhanced with tangent and interpolation support
 */
USTRUCT()
struct FManifestFloatCurveKeyDefinition
{
	GENERATED_BODY()

	float Time = 0.0f;
	float Value = 0.0f;

	// v4.0: Interpolation mode
	// "Linear" - Linear interpolation to next key
	// "Cubic" - Cubic interpolation using tangents
	// "Constant" - Constant value until next key (step function)
	// "CubicAuto" - Cubic with auto-calculated tangents
	FString InterpMode = TEXT("CubicAuto");

	// v4.0: Tangent values (only used with Cubic interp)
	float ArriveTangent = 0.0f;
	float LeaveTangent = 0.0f;

	uint64 ComputeHash() const
	{
		uint64 Hash = GetTypeHash(FString::SanitizeFloat(Time));
		Hash ^= GetTypeHash(FString::SanitizeFloat(Value)) << 8;
		Hash ^= GetTypeHash(InterpMode) << 16;
		Hash ^= GetTypeHash(FString::SanitizeFloat(ArriveTangent)) << 24;
		Hash ^= GetTypeHash(FString::SanitizeFloat(LeaveTangent)) << 32;
		return Hash;
	}
};
```

### Code: Generator Enhancement

Update `FFloatCurveGenerator::Generate()` (around line ~6900):

```cpp
FGenerationResult FFloatCurveGenerator::Generate(const FManifestFloatCurveDefinition& Definition)
{
	FString Folder = Definition.Folder.IsEmpty() ? TEXT("Curves") : Definition.Folder;
	FString AssetPath = FString::Printf(TEXT("%s/%s/%s"), *GetProjectRoot(), *Folder, *Definition.Name);
	FGenerationResult Result;

	if (ValidateAgainstManifest(Definition.Name, TEXT("Float Curve"), Result))
	{
		return Result;
	}

	if (CheckExistsWithMetadata(AssetPath, Definition.Name, TEXT("Float Curve"), Definition.ComputeHash(), Result))
	{
		return Result;
	}

	UPackage* Package = CreatePackage(*AssetPath);
	if (!Package)
	{
		return FGenerationResult(Definition.Name, EGenerationStatus::Failed, TEXT("Failed to create package"));
	}

	UCurveFloat* FloatCurve = NewObject<UCurveFloat>(Package, *Definition.Name, RF_Public | RF_Standalone);
	if (!FloatCurve)
	{
		return FGenerationResult(Definition.Name, EGenerationStatus::Failed, TEXT("Failed to create Float Curve"));
	}

	// v4.0: Add keys with full tangent and interpolation support
	for (const auto& KeyDef : Definition.Keys)
	{
		// Determine interpolation mode
		ERichCurveInterpMode InterpMode = RCIM_Cubic;
		if (KeyDef.InterpMode.Equals(TEXT("Linear"), ESearchCase::IgnoreCase))
		{
			InterpMode = RCIM_Linear;
		}
		else if (KeyDef.InterpMode.Equals(TEXT("Constant"), ESearchCase::IgnoreCase))
		{
			InterpMode = RCIM_Constant;
		}
		else if (KeyDef.InterpMode.Equals(TEXT("Cubic"), ESearchCase::IgnoreCase) ||
				 KeyDef.InterpMode.Equals(TEXT("CubicAuto"), ESearchCase::IgnoreCase))
		{
			InterpMode = RCIM_Cubic;
		}

		// Add key to curve
		FKeyHandle KeyHandle = FloatCurve->FloatCurve.AddKey(KeyDef.Time, KeyDef.Value);

		// v4.0: Set interpolation mode
		FloatCurve->FloatCurve.SetKeyInterpMode(KeyHandle, InterpMode);

		// v4.0: Set tangents for Cubic mode
		if (InterpMode == RCIM_Cubic)
		{
			if (KeyDef.InterpMode.Equals(TEXT("CubicAuto"), ESearchCase::IgnoreCase))
			{
				// Auto-calculate tangents
				FloatCurve->FloatCurve.SetKeyTangentMode(KeyHandle, RCTM_Auto);
			}
			else
			{
				// Use explicit tangents
				FloatCurve->FloatCurve.SetKeyTangentMode(KeyHandle, RCTM_User);
				FRichCurveKey& Key = FloatCurve->FloatCurve.GetKey(KeyHandle);
				Key.ArriveTangent = KeyDef.ArriveTangent;
				Key.LeaveTangent = KeyDef.LeaveTangent;
			}
		}
	}

	// v4.0: Auto-calculate tangents for CubicAuto keys
	FloatCurve->FloatCurve.AutoSetTangents();

	FAssetRegistryModule::AssetCreated(FloatCurve);
	Package->MarkPackageDirty();
	FString PackageFileName = FPackageName::LongPackageNameToFilename(AssetPath, FPackageName::GetAssetPackageExtension());
	FSavePackageArgs SaveArgs;
	SaveArgs.TopLevelFlags = RF_Public | RF_Standalone;
	UPackage::SavePackage(Package, FloatCurve, *PackageFileName, SaveArgs);

	LogGeneration(FString::Printf(TEXT("Created Float Curve: %s with %d keys"),
		*Definition.Name, Definition.Keys.Num()));

	// Store metadata
	StoreDataAssetMetadata(FloatCurve, TEXT("FloatCurve"), Definition.Name, Definition.ComputeHash());

	Result = FGenerationResult(Definition.Name, EGenerationStatus::New,
		FString::Printf(TEXT("Created at %s"), *AssetPath));
	Result.DetermineCategory();
	return Result;
}
```

### Code: Parser Enhancement

Update key parsing in `ParseFloatCurves()`:

```cpp
// When parsing key properties:
else if (bInKey)
{
	if (TrimmedLine.StartsWith(TEXT("time:")))
	{
		CurrentKey.Time = FCString::Atof(*GetLineValue(TrimmedLine));
	}
	else if (TrimmedLine.StartsWith(TEXT("value:")))
	{
		CurrentKey.Value = FCString::Atof(*GetLineValue(TrimmedLine));
	}
	// v4.0: New properties
	else if (TrimmedLine.StartsWith(TEXT("interp:")))
	{
		CurrentKey.InterpMode = GetLineValue(TrimmedLine);
	}
	else if (TrimmedLine.StartsWith(TEXT("arrive_tangent:")))
	{
		CurrentKey.ArriveTangent = FCString::Atof(*GetLineValue(TrimmedLine));
	}
	else if (TrimmedLine.StartsWith(TEXT("leave_tangent:")))
	{
		CurrentKey.LeaveTangent = FCString::Atof(*GetLineValue(TrimmedLine));
	}
}
```

---

## Testing Checklist

### Priority 1: Gameplay Cues (GC_)

- [ ] Parser correctly reads `gameplay_cues:` section
- [ ] Burst type creates `UGameplayCueNotify_Burst` child
- [ ] BurstLatent type creates `UGameplayCueNotify_BurstLatent` child
- [ ] Actor type creates `AGameplayCueNotify_Actor` child
- [ ] `GameplayCueTag` property is set on CDO
- [ ] `DefaultSpawnCondition` properties populate
- [ ] `BurstEffects` particle/sound references load
- [ ] v3.0 metadata system works for regeneration
- [ ] Prefix validation rejects non-GC_ names

### Priority 2: Animation Notifies (NAS_)

- [ ] Variables array populates on Blueprint
- [ ] Event graph generates with nodes and connections
- [ ] AnimNotifyState gets NotifyBegin/Tick/End stubs
- [ ] AnimNotify gets Notify stub
- [ ] Referenced event graphs resolve from manifest
- [ ] Inline event graphs generate correctly

### Priority 3: Narrative Events (NE_)

- [ ] NPCTargets array populates with loaded UNPCDefinition
- [ ] CharacterTargets array populates with loaded UCharacterDefinition
- [ ] Missing assets log warnings but don't fail
- [ ] Soft object pointers properly set
- [ ] Fallback to logging-only for unsupported property types

### Priority 4: Dialogue Speakers (DBP_)

- [ ] Speakers array populates with FSpeakerInfo structs
- [ ] NPCDataAsset loads and links correctly
- [ ] NodeColor parses from hex string
- [ ] OwnedTags populate FGameplayTagContainer
- [ ] PlayerSpeakerInfo configures properly
- [ ] Auto-detection logs discovered speakers from tree

### Priority 5: Float Curves (FC_)

- [ ] Linear interpolation mode works
- [ ] Cubic interpolation with explicit tangents works
- [ ] Constant (step) interpolation mode works
- [ ] CubicAuto calculates tangents automatically
- [ ] Keys sort by time correctly

---

## Manifest Test Cases

Add to `manifest.yaml` for testing:

```yaml
# v4.0 Test Cases

gameplay_cues:
  - name: GC_Test_Burst
    folder: Test/GameplayCues
    cue_type: Burst
    gameplay_cue_tag: GameplayCue.Test.Burst
    burst_effects:
      sound: TestSound

  - name: GC_Test_BurstLatent
    folder: Test/GameplayCues
    cue_type: BurstLatent
    gameplay_cue_tag: GameplayCue.Test.BurstLatent

animation_notifies:
  - name: NAS_Test_WithGraph
    folder: Test/Notifies
    variables:
      - name: TestVar
        type: Float
        default_value: "1.0"
    event_graph:
      nodes:
        - id: Begin
          type: Event
          properties:
            event_name: Received_NotifyBegin
        - id: Print
          type: PrintString
          properties:
            message: "Notify fired!"
      connections:
        - from: [Begin, Then]
          to: [Print, Exec]

float_curves:
  - name: FC_Test_Tangents
    folder: Test/Curves
    keys:
      - time: 0.0
        value: 0.0
        interp: Cubic
        arrive_tangent: 0.0
        leave_tangent: 2.0
      - time: 1.0
        value: 1.0
        interp: Linear
```

---

## Version History

- **v4.0** - Automation Enhancement Release
  - NEW: Gameplay Cue Generator (GC_) - 0%  75%
  - ENHANCED: Animation Notify event graph support - 30%  75%
  - ENHANCED: Narrative Event NPC target population - 60%  85%
  - ENHANCED: Dialogue Blueprint speaker automation - 65%  80%
  - ENHANCED: Float Curve tangent/interpolation support - 40%  85%
