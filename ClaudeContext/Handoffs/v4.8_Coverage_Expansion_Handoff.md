# v4.8 Coverage Expansion Handoff

## Executive Summary

This document captures comprehensive analysis and implementation plans for expanding GasAbilityGenerator from 92% to 98% automation coverage, adding 2 new table editors, and implementing 15+ manifest expansion features.

**Version:** v4.8
**Date:** January 2026
**Scope:** Generator gaps, manifest expansions, table editors

---

## Part 1: Current State Analysis

### Generator Coverage (32 Total)

| Category | Count | Coverage | Notes |
|----------|-------|----------|-------|
| Fully Automated | 24 | 100% | E_, IA_, IMC_, BB_, FC_, IC_, NPC_, CD_, AC_, etc. |
| High Automation | 6 | 90-98% | GA_, GE_, BP_, WBP_, DBP_, BT_ |
| Partial Automation | 2 | 70-88% | Quest_, NiagaraSystem |
| Not Automated | 2 | 0% | TriggerSets, Advanced Weapon Attachments |

### Properties Currently "Logged for Manual Setup"

1. **EquipmentEffectValues** - TMap<FGameplayTag, float> for weapon stats
2. **CharacterAppearance Materials** - Mesh material overrides
3. **Weapon Attachments** - TMap<FGameplayTag, FWeaponAttachmentConfig>
4. **Dialogue Camera Paths** - FTransform arrays for cinematics
5. **Complex Conditions** - Nested AND/OR logic for quests/dialogues
6. **Motion Warping Constraints** - Ability motion warping config
7. **Niagara FX Modules** - Emitter module stacking

---

## Part 2: Generator Gap Closures

### 2.1 EquipmentEffectValues TMap (FEquippableItemGenerator)

**Current:** Logged only, not automated
**Target:** Full TMap population via FScriptMapHelper

**Manifest Addition:**
```yaml
equippable_items:
  - name: EI_EnchantedSword
    equipment_effect_values:
      - tag: Stat.Damage.Physical
        value: 25.0
      - tag: Stat.CritChance
        value: 0.15
      - tag: Stat.AttackSpeed
        value: 1.2
```

**Implementation:**
```cpp
// In FEquippableItemGenerator::Generate()
if (Definition.EquipmentEffectValues.Num() > 0)
{
    FMapProperty* MapProp = CastField<FMapProperty>(
        ItemClass->FindPropertyByName(TEXT("EquipmentEffectValues")));
    if (MapProp)
    {
        FScriptMapHelper MapHelper(MapProp, MapProp->ContainerPtrToValuePtr<void>(ItemCDO));
        MapHelper.EmptyValues();

        for (const FManifestEquipmentEffectValue& EffectValue : Definition.EquipmentEffectValues)
        {
            FGameplayTag Tag = FGameplayTag::RequestGameplayTag(FName(*EffectValue.Tag));
            MapHelper.AddPair(&Tag, &EffectValue.Value);
        }
    }
}
```

**Structs Required:**
```cpp
USTRUCT()
struct FManifestEquipmentEffectValue
{
    GENERATED_BODY()
    FString Tag;
    float Value = 0.0f;
};

// Add to FManifestEquippableItemDefinition:
TArray<FManifestEquipmentEffectValue> EquipmentEffectValues;
```

---

### 2.2 Ability Activation Callbacks (FGameplayAbilityGenerator)

**Current:** Event graph only
**Target:** Declarative lifecycle callbacks

**Manifest Addition:**
```yaml
gameplay_abilities:
  - name: GA_AttackWithFeedback
    activation_callbacks:
      on_activated:
        - function: PlayAttackSound
          parameters:
            sound_event: SFX_AttackStart
        - function: StartCameraShake
          parameters:
            shake_class: CS_MeleeAttack
      on_ended:
        - function: ResetComboState
      on_cancelled:
        - function: PlayCancelSound
```

**Implementation Pattern:**
- Parse callbacks into FManifestAbilityCallback structs
- Generate K2Node_CustomEvent for each callback
- Wire to function calls in event graph

**Structs Required:**
```cpp
USTRUCT()
struct FManifestAbilityCallbackParam
{
    GENERATED_BODY()
    FString ParamName;
    FString ParamValue;
};

USTRUCT()
struct FManifestAbilityCallback
{
    GENERATED_BODY()
    FString FunctionName;
    TArray<FManifestAbilityCallbackParam> Parameters;
};

USTRUCT()
struct FManifestActivationCallbacks
{
    GENERATED_BODY()
    TArray<FManifestAbilityCallback> OnActivated;
    TArray<FManifestAbilityCallback> OnEnded;
    TArray<FManifestAbilityCallback> OnCancelled;
};

// Add to FManifestGameplayAbilityDefinition:
FManifestActivationCallbacks ActivationCallbacks;
```

---

### 2.3 Gameplay Tag Auto-Population

**Current:** Manual tag arrays
**Target:** Parent inheritance + auto-cleanup

**Manifest Addition:**
```yaml
gameplay_abilities:
  - name: GA_ChildAbility
    parent_class: GA_ParentAbility
    auto_inherit_parent_tags: true
    tag_removal_on_end: true
    tags:
      ability_tags:
        - Ability.Child.Specific  # Added to parent's tags
```

**Implementation:**
```cpp
// In FGameplayAbilityGenerator::Generate()
if (Definition.bAutoInheritParentTags && ParentAbility)
{
    // Get parent's tag containers
    FGameplayTagContainer ParentAbilityTags;
    ParentAbility->GetOwnedGameplayTags(ParentAbilityTags);

    // Merge with definition tags
    for (const FGameplayTag& Tag : ParentAbilityTags)
    {
        AbilityCDO->AbilityTags.AddTag(Tag);
    }
}

if (Definition.bTagRemovalOnEnd)
{
    // Set flag on ability CDO
    AbilityCDO->bRemoveActivationOwnedTagsOnEnd = true;
}
```

**Structs Required:**
```cpp
// Add to FManifestGameplayAbilityDefinition:
bool bAutoInheritParentTags = false;
bool bTagRemovalOnEnd = false;
```

---

### 2.4 Complex Condition Chains (Quest/Dialogue)

**Current:** Single conditions only
**Target:** Nested AND/OR logic trees

**Manifest Addition:**
```yaml
quests:
  - name: Quest_ComplexGate
    states:
      - id: GateCheck
        conditions:
          logic: AND
          children:
            - type: HasItem
              properties:
                item: EI_GateKey
            - logic: OR
              children:
                - type: QuestComplete
                  properties:
                    quest: Quest_Prologue
                - type: HasTag
                  properties:
                    tag: Player.VIP
```

**Implementation:**
```cpp
USTRUCT()
struct FManifestConditionNode
{
    GENERATED_BODY()

    // For leaf conditions
    FString Type;  // "HasItem", "QuestComplete", etc.
    TMap<FString, FString> Properties;
    bool bNot = false;

    // For logic nodes
    FString Logic;  // "AND", "OR", empty for leaf
    TArray<FManifestConditionNode> Children;

    bool IsLogicNode() const { return !Logic.IsEmpty(); }
};

// Recursive evaluation in generator:
UNarrativeCondition* CreateConditionTree(const FManifestConditionNode& Node)
{
    if (Node.IsLogicNode())
    {
        UNarrativeCondition_Logic* LogicCond = NewObject<UNarrativeCondition_Logic>();
        LogicCond->LogicType = Node.Logic == "AND" ? ELogicType::AND : ELogicType::OR;

        for (const FManifestConditionNode& Child : Node.Children)
        {
            LogicCond->Conditions.Add(CreateConditionTree(Child));
        }
        return LogicCond;
    }
    else
    {
        return CreateLeafCondition(Node);
    }
}
```

---

### 2.5 Attribute Initialization Overrides (FAbilityConfigurationGenerator)

**Current:** Single GE reference for defaults
**Target:** Per-attribute customization

**Manifest Addition:**
```yaml
ability_configurations:
  - name: AC_CustomBoss
    abilities: [GA_BossAttack]
    attribute_overrides:
      - attribute: Health
        base_value: 1000.0
        min_value: 0.0
        max_value: 1000.0
      - attribute: Damage
        base_value: 50.0
      - attribute: Armor
        base_value: 25.0
        clamp_to_max: false
```

**Implementation:**
- Generate a custom GE_AttributeInit_{ConfigName} asset
- Populate with FAttributeModifierMagnitude for each override
- Set as default_attributes on the configuration

**Structs Required:**
```cpp
USTRUCT()
struct FManifestAttributeOverride
{
    GENERATED_BODY()
    FString AttributeName;  // "Health", "Damage", etc.
    float BaseValue = 0.0f;
    float MinValue = 0.0f;
    float MaxValue = FLT_MAX;
    bool bClampToMax = true;
};

// Add to FManifestAbilityConfigurationDefinition:
TArray<FManifestAttributeOverride> AttributeOverrides;
```

---

### 2.6 BT Node Parameter Binding (FBehaviorTreeGenerator)

**Current:** Basic properties via reflection
**Target:** Full parameter binding with type validation

**Manifest Addition:**
```yaml
behavior_trees:
  - name: BT_AdvancedPatrol
    nodes:
      - id: MoveToTarget
        type: Task
        task_class: BTTask_MoveTo
        parameters:
          AcceptableRadius: 50.0
          bAllowStrafe: true
          bStopOnOverlap: false
          bUsePathfinding: true
          ObservedBlackboardValueTolerance: 10.0
```

**Implementation:**
```cpp
// In FBehaviorTreeGenerator when creating task nodes:
for (const auto& Param : NodeDef.Parameters)
{
    FProperty* Prop = TaskClass->FindPropertyByName(FName(*Param.Key));
    if (Prop)
    {
        void* ValuePtr = Prop->ContainerPtrToValuePtr<void>(TaskInstance);

        if (FFloatProperty* FloatProp = CastField<FFloatProperty>(Prop))
        {
            FloatProp->SetPropertyValue(ValuePtr, FCString::Atof(*Param.Value));
        }
        else if (FBoolProperty* BoolProp = CastField<FBoolProperty>(Prop))
        {
            BoolProp->SetPropertyValue(ValuePtr, Param.Value.ToBool());
        }
        // ... other types
    }
}
```

**Structs Required:**
```cpp
// Already exists in FManifestBehaviorTreeNodeDefinition:
TMap<FString, FString> Properties;
// Rename to Parameters or add alias
```

---

### 2.7 Blueprint Component Initialization (FActorBlueprintGenerator)

**Current:** Components created but not configured
**Target:** Full property initialization

**Manifest Addition:**
```yaml
actor_blueprints:
  - name: BP_ConfiguredActor
    components:
      - name: RootMesh
        type: StaticMeshComponent
        is_root: true
        properties:
          StaticMesh: /Game/Meshes/SM_Cube
          RelativeLocation: "0, 0, 100"
          RelativeScale3D: "2, 2, 2"
          bGenerateOverlapEvents: true
          CollisionProfileName: BlockAll
      - name: TriggerVolume
        type: BoxComponent
        attach_to: RootMesh
        properties:
          BoxExtent: "100, 100, 100"
          bGenerateOverlapEvents: true
          CollisionProfileName: OverlapAll
```

**Implementation:**
```cpp
// After creating component in SimpleConstructionScript:
for (const auto& PropPair : ComponentDef.Properties)
{
    FProperty* Prop = ComponentClass->FindPropertyByName(FName(*PropPair.Key));
    if (Prop)
    {
        SetPropertyFromString(ComponentTemplate, Prop, PropPair.Value);
    }
}

// Helper for common types:
void SetPropertyFromString(UObject* Obj, FProperty* Prop, const FString& Value)
{
    if (FStructProperty* StructProp = CastField<FStructProperty>(Prop))
    {
        if (StructProp->Struct == TBaseStructure<FVector>::Get())
        {
            FVector Vec;
            Vec.InitFromString(Value);
            StructProp->CopyCompleteValue(StructProp->ContainerPtrToValuePtr<void>(Obj), &Vec);
        }
        // ... FRotator, FTransform, etc.
    }
    // ... other property types
}
```

**Structs Required:**
```cpp
USTRUCT()
struct FManifestComponentDefinition
{
    GENERATED_BODY()
    FString Name;
    FString Type;  // "StaticMeshComponent", "BoxComponent", etc.
    FString AttachTo;
    bool bIsRoot = false;
    TMap<FString, FString> Properties;
};

// Add to FManifestActorBlueprintDefinition:
TArray<FManifestComponentDefinition> Components;
```

---

### 2.8 Activity Interrupt Conditions (FActivityGenerator)

**Current:** Tag-based only
**Target:** Complex interrupt logic

**Manifest Addition:**
```yaml
activities:
  - name: BPA_SmartPatrol
    behavior_tree: BT_Patrol
    interrupt_conditions:
      - type: HealthBelow
        threshold: 0.3
        priority_boost: 50.0
      - type: EnemyInRange
        range: 500.0
        tag_filter: Enemy.Hostile
      - type: TimeElapsed
        duration: 120.0
        action: Restart
```

**Implementation:**
- Generate interrupt check nodes in the activity's behavior tree
- Or create custom UNarrativeCondition subclasses for each interrupt type

**Structs Required:**
```cpp
USTRUCT()
struct FManifestInterruptCondition
{
    GENERATED_BODY()
    FString Type;  // "HealthBelow", "EnemyInRange", "TimeElapsed"
    TMap<FString, FString> Parameters;
    float PriorityBoost = 0.0f;
    FString Action;  // "Interrupt", "Restart", "Switch"
};

// Add to FManifestActivityDefinition:
TArray<FManifestInterruptCondition> InterruptConditions;
```

---

## Part 3: Table Editors

### 3.1 Quest Table Editor

**Files to Create:**
- `Source/GasAbilityGenerator/Private/QuestTableEditor/QuestTableEditorTypes.h`
- `Source/GasAbilityGenerator/Private/QuestTableEditor/SQuestTableEditor.h`
- `Source/GasAbilityGenerator/Private/QuestTableEditor/SQuestTableEditor.cpp`
- `Source/GasAbilityGenerator/Private/QuestTableEditor/QuestTableConverter.h`
- `Source/GasAbilityGenerator/Private/QuestTableEditor/QuestTableConverter.cpp`
- `Source/GasAbilityGenerator/Private/QuestTableEditor/QuestXLSXSync.h`
- `Source/GasAbilityGenerator/Private/QuestTableEditor/QuestXLSXSync.cpp`

**Column Structure (12 columns):**

| Column | Type | Width | Property |
|--------|------|-------|----------|
| Status | Badge | 0.04 | Row validation state |
| Quest Name | Text | 0.08 | Asset name |
| Display Name | Text | 0.10 | In-game title |
| State ID | Text | 0.06 | State identifier |
| State Type | Dropdown | 0.05 | Regular/Success/Failure |
| Description | Text | 0.15 | State description |
| Parent Branch | Text | 0.06 | Branch leading to state |
| Tasks | Token | 0.12 | BPT_* task tokens |
| Events | Token | 0.10 | NE_* event tokens |
| Conditions | Token | 0.10 | NC_* condition tokens |
| Rewards | Token | 0.08 | Currency/XP/Items |
| Notes | Text | 0.06 | Designer notes |

**Task Token Specs:**
```
BPT_FindItem(Item=EI_IronOre,Count=10)
BPT_FinishDialogue(Dialogue=DBP_Blacksmith)
BPT_Move(Location=POI_Forge,Radius=100)
BPT_KillEnemies(Tag=Enemy.Goblin,Count=5)
BPT_Wait(Duration=5.0)
```

**Reward Token Specs:**
```
Reward(Currency=100,XP=50)
Reward(Items=EI_Sword:1,EI_Potion:5)
Reward(Currency=500,XP=100,Items=EI_RareArmor:1)
```

**Row Structure:**
```cpp
USTRUCT()
struct FQuestTableRow
{
    GENERATED_BODY()

    // Identity
    FString QuestName;
    FString DisplayName;

    // State info
    FString StateID;
    EQuestStateType StateType = EQuestStateType::Regular;
    FString Description;
    FString ParentBranch;

    // Tokens
    FString Tasks;      // "BPT_FindItem(...);BPT_Move(...)"
    FString Events;     // "NE_GiveXP(...);NE_AddItem(...)"
    FString Conditions; // "NC_HasTag(...);NC_QuestState(...)"
    FString Rewards;    // "Reward(Currency=100,XP=50)"

    // Meta
    FString Notes;
    EQuestTableRowStatus Status = EQuestTableRowStatus::New;

    // Sync tracking
    uint32 LastSyncedHash = 0;
    EValidationState ValidationState = EValidationState::Unknown;
};
```

---

### 3.2 Item Table Editor

**Files to Create:**
- `Source/GasAbilityGenerator/Private/ItemTableEditor/ItemTableEditorTypes.h`
- `Source/GasAbilityGenerator/Private/ItemTableEditor/SItemTableEditor.h`
- `Source/GasAbilityGenerator/Private/ItemTableEditor/SItemTableEditor.cpp`
- `Source/GasAbilityGenerator/Private/ItemTableEditor/ItemTableConverter.h`
- `Source/GasAbilityGenerator/Private/ItemTableEditor/ItemTableConverter.cpp`
- `Source/GasAbilityGenerator/Private/ItemTableEditor/ItemXLSXSync.h`
- `Source/GasAbilityGenerator/Private/ItemTableEditor/ItemXLSXSync.cpp`

**Column Structure (16 columns):**

| Column | Type | Width | Property |
|--------|------|-------|----------|
| Status | Badge | 0.03 | Row state |
| Item Name | Text | 0.08 | Asset name |
| Display Name | Text | 0.08 | In-game name |
| Item Type | Dropdown | 0.06 | Equippable/Ranged/Melee |
| Slot | Dropdown | 0.06 | Equipment slot tag |
| Base Value | Int | 0.04 | Gold worth |
| Weight | Float | 0.04 | Inventory weight |
| Attack Rating | Float | 0.04 | Weapon damage |
| Armor Rating | Float | 0.04 | Damage reduction |
| Modifier GE | Asset | 0.08 | GE_* reference |
| Abilities | Multi | 0.10 | GA_* grants |
| Weapon Config | Token | 0.10 | Weapon-specific |
| Item Tags | Multi | 0.06 | Gameplay tags |
| Stackable | Check | 0.02 | Boolean |
| Stack Limit | Int | 0.03 | Max stack |
| Notes | Text | 0.07 | Notes |

**Dynamic Column Visibility:**
- Weapon Config only visible when Item Type = Ranged or Melee
- Attack Rating only for weapons
- Armor Rating only for armor

**Weapon Config Token Specs:**
```
# Ranged weapons
Weapon(Damage=50,ClipSize=30,ReloadTime=2.5,Range=2000,Spread=1.0)

# Melee weapons
Weapon(Damage=75,Range=200,ComboCount=3,StaggerChance=0.3)
```

**Row Structure:**
```cpp
USTRUCT()
struct FItemTableRow
{
    GENERATED_BODY()

    // Identity
    FString ItemName;
    FString DisplayName;
    EItemType ItemType = EItemType::Equippable;

    // Core stats
    FString EquipmentSlot;  // Tag string
    int32 BaseValue = 0;
    float Weight = 1.0f;
    float AttackRating = 0.0f;
    float ArmorRating = 0.0f;

    // References
    FString ModifierGE;     // GE_* asset name
    TArray<FString> Abilities;  // GA_* asset names
    TArray<FString> ItemTags;   // Gameplay tags

    // Weapon config (token)
    FString WeaponConfig;

    // Stack
    bool bStackable = false;
    int32 MaxStackSize = 1;

    // Meta
    FString Notes;
    EItemTableRowStatus Status = EItemTableRowStatus::New;
    uint32 LastSyncedHash = 0;
};
```

---

## Part 4: Manifest Expansion Summary

### New Struct Additions to GasAbilityGeneratorTypes.h

```cpp
// Equipment effect values
USTRUCT()
struct FManifestEquipmentEffectValue
{
    GENERATED_BODY()
    FString Tag;
    float Value = 0.0f;
};

// Ability callbacks
USTRUCT()
struct FManifestAbilityCallbackParam
{
    GENERATED_BODY()
    FString ParamName;
    FString ParamValue;
};

USTRUCT()
struct FManifestAbilityCallback
{
    GENERATED_BODY()
    FString FunctionName;
    TArray<FManifestAbilityCallbackParam> Parameters;
};

USTRUCT()
struct FManifestActivationCallbacks
{
    GENERATED_BODY()
    TArray<FManifestAbilityCallback> OnActivated;
    TArray<FManifestAbilityCallback> OnEnded;
    TArray<FManifestAbilityCallback> OnCancelled;
};

// Condition tree nodes
USTRUCT()
struct FManifestConditionNode
{
    GENERATED_BODY()
    FString Type;
    TMap<FString, FString> Properties;
    bool bNot = false;
    FString Logic;  // "AND", "OR"
    TArray<FManifestConditionNode> Children;
};

// Attribute overrides
USTRUCT()
struct FManifestAttributeOverride
{
    GENERATED_BODY()
    FString AttributeName;
    float BaseValue = 0.0f;
    float MinValue = 0.0f;
    float MaxValue = FLT_MAX;
    bool bClampToMax = true;
};

// Component definitions
USTRUCT()
struct FManifestComponentDefinition
{
    GENERATED_BODY()
    FString Name;
    FString Type;
    FString AttachTo;
    bool bIsRoot = false;
    TMap<FString, FString> Properties;
};

// Interrupt conditions
USTRUCT()
struct FManifestInterruptCondition
{
    GENERATED_BODY()
    FString Type;
    TMap<FString, FString> Parameters;
    float PriorityBoost = 0.0f;
    FString Action;
};
```

### Parser Additions Required

New sections to parse in GasAbilityGeneratorParser.cpp:
- `equipment_effect_values:` in equippable_items
- `activation_callbacks:` in gameplay_abilities
- `auto_inherit_parent_tags:` in gameplay_abilities
- `attribute_overrides:` in ability_configurations
- `parameters:` in behavior_tree nodes (enhanced)
- `components:` with properties in actor_blueprints
- `interrupt_conditions:` in activities
- `conditions:` with nested logic in quests/dialogues

---

## Part 5: Implementation Checklist

### Phase 1: Generator Gaps
- [ ] EquipmentEffectValues TMap in FEquippableItemGenerator
- [ ] Ability activation callbacks in FGameplayAbilityGenerator
- [ ] Tag auto-population in FGameplayAbilityGenerator
- [ ] Complex condition chains in FQuestGenerator and FDialogueBlueprintGenerator

### Phase 2: Manifest Expansions
- [ ] Attribute initialization overrides in FAbilityConfigurationGenerator
- [ ] BT node parameter binding in FBehaviorTreeGenerator
- [ ] Blueprint component initialization in FActorBlueprintGenerator
- [ ] Activity interrupt conditions in FActivityGenerator

### Phase 3: Table Editors
- [ ] Quest Table Editor (SQuestTableEditor)
- [ ] Item Table Editor (SItemTableEditor)
- [ ] XLSX sync for both editors
- [ ] Token validation for task/reward/condition tokens

### Phase 4: Testing & Documentation
- [ ] Unit tests for new parsers
- [ ] Integration tests for generators
- [ ] Update CLAUDE.md with new features
- [ ] Update manifest.yaml with examples

---

## Part 6: Future Expansion (Deferred)

The following were identified but deferred to future versions:

### Table Editors (v4.9+)
- Activity Schedule Table Editor
- Ability Configuration Table Editor
- Goal Item Table Editor

### Generator Expansions (v5.0+)
- Trigger Set event graph generation
- Dialogue camera shot sequences
- Niagara FX module configuration
- Widget Blueprint data binding
- Material expression networks

### Manifest Expansions (v5.0+)
- Input modifier conditions (hold duration, dead zones)
- NPC vendor trade filters
- Equippable item animation overrides
- Trigger set event propagation

---

## Part 7: Risk Mitigation

| Risk | Mitigation |
|------|------------|
| TMap population crashes | Use FScriptMapHelper with null checks |
| Complex conditions stack overflow | Limit nesting depth to 5 levels |
| Token parsing failures | Validate token specs against registry |
| Table editor performance | Use SListView virtualization |
| XLSX sync conflicts | Use per-row hash tracking |

---

## Appendix A: Full Property Lists by Generator

### FGameplayAbilityGenerator - Full Property Coverage

**Currently Set (35 properties):**
- AbilityTags, ActivationOwnedTags, ActivationRequiredTags, ActivationBlockedTags
- CancelAbilitiesWithTag, BlockAbilitiesWithTag
- InstancingPolicy, NetExecutionPolicy, ReplicationPolicy
- CostGameplayEffectClass, CooldownGameplayEffectClass
- bActivateAbilityOnGranted, InputTag
- Event graph nodes (30+ types)
- Variables (all Blueprint types)

**To Add (8 properties):**
- ActivationCallbacks (OnActivated, OnEnded, OnCancelled)
- bAutoInheritParentTags
- bTagRemovalOnEnd
- MotionWarpingConstraints
- AbilityTargetDataFilter
- ServerRPCSettings
- PredictionKey configuration
- ReplicationProxyTag

### FEquippableItemGenerator - Full Property Coverage

**Currently Set (60+ properties):**
- All NarrativeItem properties (20)
- All EquippableItem properties (7)
- All WeaponItem properties (15)
- All RangedWeaponItem properties (14)
- All MeleeWeaponItem properties (4)

**To Add (5 properties):**
- EquipmentEffectValues TMap
- WeaponAttachmentConfigs TMap
- AnimationOverrides per socket
- PhysicsParams for weapons
- RecoilCurves for ranged

### FBehaviorTreeGenerator - Full Property Coverage

**Currently Set (25 properties):**
- Root node type
- Node tree structure
- Blackboard key references
- Decorators (10 types)
- Services (5 types)
- Basic task properties

**To Add (10 properties):**
- Full parameter binding for all task properties
- Decorator parameter binding
- Service parameter binding
- Parallel execution configs
- Observer abort settings
- Flow control settings

---

## Appendix B: Token Validation Specs

### Quest Task Tokens
```
BPT_FindItem(Item=<EI_*>,Count=<int>,Optional=<bool>)
BPT_FinishDialogue(Dialogue=<DBP_*>)
BPT_Move(Location=<POI_*|FVector>,Radius=<float>)
BPT_KillEnemies(Tag=<FGameplayTag>,Count=<int>)
BPT_Wait(Duration=<float>)
BPT_Interact(Target=<AActor*>,Interaction=<FName>)
```

### Quest Reward Tokens
```
Reward(Currency=<int>,XP=<int>,Items=<EI_*:count,...>)
```

### Quest Condition Tokens
```
NC_HasItem(Item=<EI_*>,Count=<int>)
NC_HasTag(Tag=<FGameplayTag>,Not=<bool>)
NC_QuestState(Quest=<Quest_*>,State=<FName>)
NC_QuestComplete(Quest=<Quest_*>)
NC_Level(Min=<int>,Max=<int>)
```

### Item Weapon Tokens
```
Weapon(Damage=<float>,ClipSize=<int>,ReloadTime=<float>,Range=<float>,Spread=<float>)
Weapon(Damage=<float>,Range=<float>,ComboCount=<int>,StaggerChance=<float>)
```

---

*End of Handoff Document*
