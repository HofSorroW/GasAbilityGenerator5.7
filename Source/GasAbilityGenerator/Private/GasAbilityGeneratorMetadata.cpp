// GasAbilityGenerator v3.0
// Copyright (c) Erdem - Second Chance RPG. All Rights Reserved.

#include "GasAbilityGeneratorMetadata.h"
#include "Engine/Blueprint.h"
#include "Engine/DataAsset.h"

UGeneratorAssetMetadata::UGeneratorAssetMetadata()
	: InputHash(0)
	, OutputHash(0)
	, Timestamp(FDateTime::Now())
	, bIsGenerated(false)
{
}

FGeneratorMetadata UGeneratorAssetMetadata::ToMetadata() const
{
	FGeneratorMetadata Meta;
	Meta.GeneratorId = GeneratorId;
	Meta.ManifestPath = ManifestPath;
	Meta.ManifestAssetKey = ManifestAssetKey;
	Meta.InputHash = static_cast<uint64>(InputHash);
	Meta.OutputHash = static_cast<uint64>(OutputHash);
	Meta.GeneratorVersion = GeneratorVersion;
	Meta.Timestamp = Timestamp;
	Meta.Dependencies = Dependencies;
	Meta.bIsGenerated = bIsGenerated;
	return Meta;
}

void UGeneratorAssetMetadata::FromMetadata(const FGeneratorMetadata& InMetadata)
{
	GeneratorId = InMetadata.GeneratorId;
	ManifestPath = InMetadata.ManifestPath;
	ManifestAssetKey = InMetadata.ManifestAssetKey;
	InputHash = static_cast<int64>(InMetadata.InputHash);
	OutputHash = static_cast<int64>(InMetadata.OutputHash);
	GeneratorVersion = InMetadata.GeneratorVersion;
	Timestamp = InMetadata.Timestamp;
	Dependencies = InMetadata.Dependencies;
	bIsGenerated = InMetadata.bIsGenerated;
}

bool UGeneratorAssetMetadata::HasInputChanged(uint64 NewInputHash) const
{
	return static_cast<uint64>(InputHash) != NewInputHash;
}

bool UGeneratorAssetMetadata::HasOutputChanged(uint64 CurrentOutputHash) const
{
	return static_cast<uint64>(OutputHash) != CurrentOutputHash;
}

FString UGeneratorAssetMetadata::GetSummary() const
{
	return FString::Printf(TEXT("[%s] %s - InHash:%llu OutHash:%llu Ver:%s Gen:%s"),
		*GeneratorId,
		*ManifestAssetKey,
		static_cast<uint64>(InputHash),
		static_cast<uint64>(OutputHash),
		*GeneratorVersion,
		bIsGenerated ? TEXT("Yes") : TEXT("No"));
}

// ============================================================================
// Helper Functions
// ============================================================================

namespace GeneratorMetadataHelpers
{
	UGeneratorAssetMetadata* GetMetadata(UObject* Asset)
	{
		if (!Asset)
		{
			return nullptr;
		}

		// Use IInterface_AssetUserData interface for all asset types
		// Both UBlueprint and UDataAsset implement this interface
		if (IInterface_AssetUserData* AssetUserDataInterface = Cast<IInterface_AssetUserData>(Asset))
		{
			return Cast<UGeneratorAssetMetadata>(AssetUserDataInterface->GetAssetUserDataOfClass(UGeneratorAssetMetadata::StaticClass()));
		}

		return nullptr;
	}

	void SetMetadata(UObject* Asset, const FGeneratorMetadata& Metadata)
	{
		if (!Asset)
		{
			return;
		}

		// Use IInterface_AssetUserData interface
		IInterface_AssetUserData* AssetUserDataInterface = Cast<IInterface_AssetUserData>(Asset);
		if (!AssetUserDataInterface)
		{
			UE_LOG(LogTemp, Warning, TEXT("[GasAbilityGenerator] Cannot store metadata on asset %s - does not support AssetUserData"), *Asset->GetName());
			return;
		}

		UGeneratorAssetMetadata* MetaData = GetMetadata(Asset);

		// Create new if doesn't exist
		if (!MetaData)
		{
			MetaData = NewObject<UGeneratorAssetMetadata>(Asset);
			AssetUserDataInterface->AddAssetUserData(MetaData);
		}

		// Update metadata
		MetaData->FromMetadata(Metadata);

		// Mark asset as modified
		Asset->MarkPackageDirty();
	}

	void RemoveMetadata(UObject* Asset)
	{
		if (!Asset)
		{
			return;
		}

		UGeneratorAssetMetadata* MetaData = GetMetadata(Asset);
		if (!MetaData)
		{
			return;
		}

		// Use IInterface_AssetUserData interface
		if (IInterface_AssetUserData* AssetUserDataInterface = Cast<IInterface_AssetUserData>(Asset))
		{
			AssetUserDataInterface->RemoveUserDataOfClass(UGeneratorAssetMetadata::StaticClass());
		}

		Asset->MarkPackageDirty();
	}

	bool HasMetadata(UObject* Asset)
	{
		return GetMetadata(Asset) != nullptr;
	}

	EDryRunStatus ComputeDryRunStatus(
		UObject* Asset,
		uint64 NewInputHash,
		TFunction<uint64(UObject*)> ComputeCurrentOutputHash)
	{
		// No existing asset - will create new
		if (!Asset)
		{
			return EDryRunStatus::WillCreate;
		}

		// Get existing metadata
		UGeneratorAssetMetadata* MetaData = GetMetadata(Asset);

		// No metadata - asset exists but wasn't generated by us
		// Treat as skip to avoid overwriting manual assets
		if (!MetaData)
		{
			return EDryRunStatus::WillSkip;
		}

		// Check if manifest definition changed
		bool bInputChanged = MetaData->HasInputChanged(NewInputHash);

		// Check if asset was manually edited (if we have output hash computation)
		bool bOutputChanged = false;
		if (ComputeCurrentOutputHash)
		{
			uint64 CurrentOutputHash = ComputeCurrentOutputHash(Asset);
			bOutputChanged = MetaData->HasOutputChanged(CurrentOutputHash);
		}

		// Determine status based on changes
		if (!bInputChanged && !bOutputChanged)
		{
			// Nothing changed - skip
			return EDryRunStatus::WillSkip;
		}
		else if (bInputChanged && !bOutputChanged)
		{
			// Only manifest changed - safe to regenerate
			return EDryRunStatus::WillModify;
		}
		else if (bInputChanged && bOutputChanged)
		{
			// Both changed - conflict requiring user decision
			return EDryRunStatus::Conflicted;
		}
		else // !bInputChanged && bOutputChanged
		{
			// Only asset edited, manifest unchanged - skip to preserve edits
			return EDryRunStatus::WillSkip;
		}
	}
}
